<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trading Dashboard</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            color: #1f1f1f;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
            gap: 12px;
            padding: 12px;
        }

        .sidebar {
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow-y: auto;
            max-height: calc(100vh - 24px);
        }


        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-width: 0;
        }

        .card {
            background: #f9fafb;
            border-radius: 8px;
            padding: 16px;
            border: 1px solid #e5e7eb;
        }

        .card-title {
            font-size: 18px;
            font-weight: 600;
            color: #1f1f1f;
            margin-bottom: 12px;
        }

        .controls {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin-bottom: 12px;
        }

        select, button {
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #e5e7eb;
            background: #ffffff;
            color: #1f1f1f;
            font-size: 13px;
            cursor: pointer;
        }

        select:hover, button:hover {
            border-color: #3b82f6;
        }

        .status {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
        }

        .status.connected { color: #10b981; }
        .status.loading { color: #f59e0b; }
        .status.error { color: #ef4444; }

        #chart {
            flex: 1;
            min-height: 0;
            width: 100%;
            height: 100%;
        }

        #chartsView {
            flex: 1;
            display: flex;
            min-height: 0;
        }

        #paperView {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .trades-table-container {
            flex: 1;
            overflow: auto;
            min-height: 0;
        }

        .trades-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .trades-table th {
            background: #f3f4f6;
            padding: 8px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #e5e7eb;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .trades-table td {
            padding: 8px;
            border-bottom: 1px solid #e5e7eb;
        }

        .trades-table tr:hover {
            background: #f9fafb;
        }

        .trade-buy { color: #10b981; }
        .trade-sell { color: #ef4444; }
        .dir-long { color: #10b981; }
        .dir-short { color: #ef4444; }
        .trade-active { font-weight: 600; }
        .nav {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .nav-button {
            padding: 10px;
            border: 1px solid transparent;
            text-align: left;
            transition: all 0.2s;
        }

        .nav-button.active {
            background: rgba(59, 130, 246, 0.1);
            border-color: rgba(59, 130, 246, 0.3);
            color: #3b82f6;
        }

        .hidden {
            display: none !important;
        }

        /* Orchestrator View Styles */
        #orchestratorView {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .vm-card {
            background: #f9fafb;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .vm-card.running {
            border-color: #10b981;
            background: #f0fdf4;
        }

        .vm-card.stopping {
            border-color: #f59e0b;
            background: #fffbeb;
        }

        .vm-card.terminated {
            border-color: #9ca3af;
            background: #f9fafb;
        }

        .vm-status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }

        .vm-status-dot.running { background: #10b981; }
        .vm-status-dot.stopping { background: #f59e0b; }
        .vm-status-dot.terminated { background: #9ca3af; }

        .job-status-badge {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
        }

        .job-status-badge.pending {
            background: #f3f4f6;
            color: #6b7280;
        }

        .job-status-badge.running {
            background: #dbeafe;
            color: #1d4ed8;
        }

        .job-status-badge.completed {
            background: #dcfce7;
            color: #166534;
        }

        .job-status-badge.passed,
        .job-status-badge.profitable {
            background: #f3e8ff;
            color: #7c3aed;
            border: 1px solid #c4b5fd;
        }

        .job-status-badge.failed {
            background: #fee2e2;
            color: #991b1b;
        }

        .job-status-badge.phase5-failed {
            background: #fef3c7;
            color: #92400e;
        }

        .retry-btn {
            padding: 4px 8px;
            font-size: 11px;
            background: #fef3c7;
            color: #92400e;
            border: 1px solid #fcd34d;
            border-radius: 4px;
            cursor: pointer;
        }

        .retry-btn:hover {
            background: #fde68a;
        }

        .symbol-progress-card {
            background: #f9fafb;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #e5e7eb;
        }

        .pagination-btn {
            padding: 6px 12px;
            border: 1px solid #e5e7eb;
            background: #ffffff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .pagination-btn:hover {
            border-color: #3b82f6;
        }

        .pagination-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.02); }
        }

        .signal-card-urgent {
            animation: pulse 1.5s ease-in-out infinite;
        }

        /* Decision Log Styles */
        #decisionsView {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .decision-badge {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
        }

        .decision-badge.position_opened { background: #dcfce7; color: #166534; }
        .decision-badge.position_closed { background: #fee2e2; color: #991b1b; }
        .decision-badge.rl_exit_decision { background: #dbeafe; color: #1d4ed8; }
        .decision-badge.signal_generated { background: #d1fae5; color: #065f46; }
        .decision-badge.signal_rejected { background: #fef3c7; color: #92400e; }
        .decision-badge.risk_violation { background: #fce7f3; color: #9d174d; }
        .decision-badge.system_error { background: #fecaca; color: #7f1d1d; }
        .decision-badge.symbol_disabled { background: #e5e7eb; color: #374151; }

        .decision-detail-toggle {
            cursor: pointer;
            color: #3b82f6;
            font-size: 11px;
        }

        .decision-detail-toggle:hover { text-decoration: underline; }

        .decision-context {
            background: #f3f4f6;
            padding: 8px;
            border-radius: 4px;
            font-size: 11px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 200px;
            overflow: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="card" style="padding: 10px;">
                <h1 class="card-title" style="font-size: 16px; margin-bottom: 8px;">Trading Dashboard</h1>
                <div class="nav" style="gap: 2px;">
                    <button class="nav-button active" style="padding: 6px 8px; font-size: 13px;" onclick="showView('charts')">üìä Charts</button>
                    <button class="nav-button" style="padding: 6px 8px; font-size: 13px;" onclick="showView('paper')">üìà Paper Trading</button>
                    <button class="nav-button" style="padding: 6px 8px; font-size: 13px;" onclick="showView('orchestrator')">üöÄ Training Orchestrator</button>
                    <button class="nav-button" style="padding: 6px 8px; font-size: 13px;" onclick="showView('decisions')">üìù Decision Log</button>
                    <a href="/dashboard.html" class="nav-button" style="padding: 6px 8px; font-size: 13px; text-decoration: none; display: block;">üìã Advanced Dashboard</a>
                    <a href="/trades.html" class="nav-button" style="padding: 6px 8px; font-size: 13px; text-decoration: none; display: block;">üí∞ Trade Analytics</a>
                    <a href="/signal-analytics.html" class="nav-button" style="padding: 6px 8px; font-size: 13px; text-decoration: none; display: block;">üì° Signal Analytics</a>
                </div>
            </div>

            <div class="card" id="chartControls" style="padding: 12px;">
                <div style="font-size: 14px; font-weight: 600; margin-bottom: 8px;">Symbol & Timeframe</div>
                <div style="display: flex; gap: 6px; margin-bottom: 8px;">
                    <select id="symbol" onchange="loadData()" style="flex: 1;">
                        <option value="EURUSD">EUR/USD</option>
                        <option value="GBPUSD">GBP/USD</option>
                        <option value="USDJPY">USD/JPY</option>
                        <option value="EURJPY">EUR/JPY</option>
                        <option value="USDCAD">USD/CAD</option>
                        <option value="USDCHF">USD/CHF</option>
                        <option value="EURCAD">EUR/CAD</option>
                        <option value="EURGBP">EUR/GBP</option>
                    </select>
                    <select id="timeframe" onchange="loadData()" style="width: 60px;">
                        <option value="M10">M10</option>
                        <option value="M20">M20</option>
                        <option value="M30">M30</option>
                        <option value="H1" selected>H1</option>
                        <option value="H2">H2</option>
                        <option value="H3">H3</option>
                        <option value="H4">H4</option>
                        <option value="H6">H6</option>
                        <option value="H8">H8</option>
                        <option value="H12">H12</option>
                        <option value="D1">D1</option>
                    </select>
                </div>
                <div style="margin-bottom: 8px;">
                    <label style="display: block; font-size: 11px; color: #6b7280; margin-bottom: 3px;">Candles:</label>
                    <select id="candleLimit" onchange="loadData()" style="width: 100%;">
                        <option value="100">100 candles</option>
                        <option value="200">200 candles</option>
                        <option value="300" selected>300 candles</option>
                        <option value="500">500 candles</option>
                        <option value="1000">1000 candles</option>
                    </select>
                </div>
                <div style="font-size: 13px; font-weight: 600; margin-top: 10px; margin-bottom: 6px; color: #374151;">Overlay Indicators</div>
                <div style="display: flex; flex-direction: column; gap: 3px; font-size: 12px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="showSMA20" checked onchange="loadData()" style="cursor: pointer;">
                        <span>SMA 20</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="showSMA50" checked onchange="loadData()" style="cursor: pointer;">
                        <span>SMA 50</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="showSMA200" onchange="loadData()" style="cursor: pointer;">
                        <span>SMA 200</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="showEMA12" onchange="loadData()" style="cursor: pointer;">
                        <span>EMA 12</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="showEMA26" onchange="loadData()" style="cursor: pointer;">
                        <span>EMA 26</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="showEMA50" onchange="loadData()" style="cursor: pointer;">
                        <span>EMA 50</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="showBB" checked onchange="loadData()" style="cursor: pointer;">
                        <span>Bollinger Bands (20)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="showATRBands" onchange="loadData()" style="cursor: pointer;">
                        <span>ATR Bands (breakout)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="showOBB" onchange="loadData()" style="cursor: pointer;">
                        <span>OB Blocks (AI)</span>
                    </label>
                    <div id="obbStatus" style="font-size: 10px; color: #6b7280; margin-left: 24px; display: none;"></div>
                </div>
                <div style="font-size: 13px; font-weight: 600; margin-top: 10px; margin-bottom: 6px; color: #374151;">Oscillators</div>
                <div style="display: flex; flex-direction: column; gap: 3px; font-size: 12px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="showVolume" onchange="loadData()" style="cursor: pointer;">
                        <span>Volume</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="showRSI" onchange="loadData()" style="cursor: pointer;">
                        <span>RSI (14)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="showMACD" onchange="loadData()" style="cursor: pointer;">
                        <span>MACD</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="showStochastic" onchange="loadData()" style="cursor: pointer;">
                        <span>Stochastic (K, D)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="showATR" onchange="loadData()" style="cursor: pointer;">
                        <span>ATR (14)</span>
                    </label>
                </div>
                <div class="status" id="status" style="margin-top: 6px;">‚ö™ Initializing...</div>
            </div>

            <!-- Model Info Card (shown in charts view) -->
            <div class="card" id="modelInfoCard" style="flex-shrink: 0; padding: 10px;">
                <div style="font-size: 13px; font-weight: 600; margin-bottom: 6px;">ü§ñ Model Info</div>
                <div id="modelInfoContent" style="font-size: 11px;">
                    <div style="color: #6b7280; text-align: center; padding: 8px;">Loading model info...</div>
                </div>
            </div>

            <!-- Trading Models Sidebar (shown in paper trading view) -->
            <div class="card hidden" id="paperTradingModels" style="flex-shrink: 0; padding: 10px; max-height: calc(100vh - 200px); overflow-y: auto;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <div style="font-size: 13px; font-weight: 600;">ü§ñ Trading Models</div>
                    <div id="sidebarModelsStatus" style="font-size: 10px; color: #6b7280;">Loading...</div>
                </div>
                <div id="sidebarModelsContent" style="font-size: 11px;">
                    <div style="color: #6b7280; text-align: center; padding: 8px;">Loading models...</div>
                </div>
            </div>
        </div>

        <div class="main-content">
            <div id="chartsView">
                <div id="chart" class="card"></div>
            </div>

            <div id="paperView" class="hidden">
                <div class="card" style="flex: 1; display: flex; flex-direction: column; min-height: 0;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <div class="card-title">Paper Trading</div>
                        <div class="status" id="tradesStatus">‚ö™ Loading...</div>
                    </div>

                    <!-- Analytics Cards -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin-bottom: 20px;">
                        <div style="background: #f9fafb; padding: 16px; border-radius: 8px; border: 1px solid #e5e7eb;">
                            <div style="font-size: 12px; color: #6b7280; margin-bottom: 4px;">Total P/L</div>
                            <div id="analytics-total-pnl" style="font-size: 24px; font-weight: 600;">-</div>
                        </div>
                        <div style="background: #f9fafb; padding: 16px; border-radius: 8px; border: 1px solid #e5e7eb;">
                            <div style="font-size: 12px; color: #6b7280; margin-bottom: 4px;">Win Rate</div>
                            <div id="analytics-win-rate" style="font-size: 24px; font-weight: 600;">-</div>
                        </div>
                        <div style="background: #f9fafb; padding: 16px; border-radius: 8px; border: 1px solid #e5e7eb;">
                            <div style="font-size: 12px; color: #6b7280; margin-bottom: 4px;">Total Trades</div>
                            <div id="analytics-total-trades" style="font-size: 24px; font-weight: 600;">-</div>
                        </div>
                        <div style="background: #f0f9ff; padding: 16px; border-radius: 8px; border: 1px solid #bae6fd;">
                            <div style="font-size: 12px; color: #6b7280; margin-bottom: 4px;">MT5 Account</div>
                            <div id="balancePLN" style="font-size: 18px; font-weight: 600;">Fetching...</div>
                            <div id="balanceSource" style="font-size: 11px; color: #9ca3af; margin-top: 2px;">‚Üí waiting for gateway</div>
                        </div>
                    </div>

                    <!-- Filter Bar -->
                    <div id="tradeFilters" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 12px; align-items: center;">
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <label style="font-size: 11px; color: #6b7280; font-weight: 600;">Date:</label>
                            <input type="date" id="filterDate" style="padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 12px;" onchange="applyTradeFilters()" title="Filter by close date (exit date for closed trades)">
                        </div>
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <label style="font-size: 11px; color: #6b7280; font-weight: 600;">Symbol:</label>
                            <select id="filterSymbol" style="padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 12px;" onchange="applyTradeFilters()">
                                <option value="">All</option>
                            </select>
                        </div>
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <label style="font-size: 11px; color: #6b7280; font-weight: 600;">Type:</label>
                            <select id="filterType" style="padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 12px;" onchange="applyTradeFilters()">
                                <option value="">All</option>
                                <option value="long">LONG</option>
                                <option value="short">SHORT</option>
                            </select>
                        </div>
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <label style="font-size: 11px; color: #6b7280; font-weight: 600;">Model:</label>
                            <select id="filterModel" style="padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 12px; max-width: 220px;" onchange="applyTradeFilters()">
                                <option value="">All</option>
                            </select>
                        </div>
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <label style="font-size: 11px; color: #6b7280; font-weight: 600;">Status:</label>
                            <select id="filterStatus" style="padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 12px;" onchange="applyTradeFilters()">
                                <option value="">All</option>
                                <option value="OPEN">OPEN</option>
                                <option value="CLOSED">CLOSED</option>
                            </select>
                        </div>
                        <button onclick="clearTradeFilters()" style="padding: 4px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 12px; background: #f9fafb; cursor: pointer;">Clear</button>
                        <span id="filterCount" style="font-size: 11px; color: #6b7280; margin-left: auto;"></span>
                    </div>

                    <!-- Trades Table -->
                    <div class="trades-table-container" style="flex: 1; min-height: 300px;">
                        <table class="trades-table">
                            <thead>
                                <tr>
                                    <th>ID</th>
                                    <th>Symbol</th>
                                    <th>Type</th>
                                    <th>Lots</th>
                                    <th>Entry</th>
                                    <th>Current</th>
                                    <th>P/L Pips</th>
                                    <th>P/L (MT5)</th>
                                    <th>Model</th>
                                    <th>TF</th>
                                    <th>Opened</th>
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody id="tradesBody">
                                <tr><td colspan="12" style="text-align: center; padding: 40px;">Loading trades...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div id="orchestratorView" class="hidden">
                <div class="card" style="flex: 1; display: flex; flex-direction: column; min-height: 0; overflow: auto;">
                    <!-- Header with controls -->
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <div class="card-title">Training Orchestrator</div>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <button id="orchestratorStartBtn" onclick="startOrchestrator()" style="background: #10b981; color: white; border: none; padding: 8px 16px;">Start</button>
                            <button id="orchestratorPauseBtn" onclick="pauseOrchestrator()" style="background: #f59e0b; color: white; border: none; padding: 8px 16px;">Pause</button>
                            <button onclick="loadOrchestratorData()" style="padding: 8px 16px;">Refresh</button>
                            <div class="status" id="orchestratorStatus">‚ö™ Loading...</div>
                        </div>
                    </div>

                    <!-- Overall Progress Section -->
                    <div style="margin-bottom: 20px;">
                        <div style="font-size: 14px; font-weight: 600; margin-bottom: 8px;">Overall Progress</div>
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                            <div style="flex: 1; background: #e5e7eb; border-radius: 8px; height: 24px; overflow: hidden;">
                                <div id="orchestrator-progress-bar" style="background: #10b981; height: 100%; width: 0%; transition: width 0.3s;"></div>
                            </div>
                            <div id="orchestrator-progress-text" style="font-size: 16px; font-weight: 600; min-width: 80px;">0/0</div>
                        </div>
                        <!-- Status counts -->
                        <div style="display: flex; gap: 16px; flex-wrap: wrap;">
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <span style="width: 12px; height: 12px; background: #10b981; border-radius: 50%;"></span>
                                <span>Completed: <strong id="orchestrator-completed-count">0</strong></span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <span style="width: 12px; height: 12px; background: #8b5cf6; border-radius: 50%;"></span>
                                <span>Profitable: <strong id="orchestrator-profitable-count">0</strong></span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <span style="width: 12px; height: 12px; background: #3b82f6; border-radius: 50%;"></span>
                                <span>Running: <strong id="orchestrator-running-count">0</strong></span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <span style="width: 12px; height: 12px; background: #ef4444; border-radius: 50%;"></span>
                                <span>Failed: <strong id="orchestrator-failed-count">0</strong></span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <span style="width: 12px; height: 12px; background: #9ca3af; border-radius: 50%;"></span>
                                <span>Pending: <strong id="orchestrator-pending-count">0</strong></span>
                            </div>
                        </div>
                    </div>

                    <!-- Per-Symbol Progress -->
                    <div style="margin-bottom: 20px;">
                        <div style="font-size: 14px; font-weight: 600; margin-bottom: 8px;">Per-Symbol Progress</div>
                        <div id="orchestrator-symbol-progress" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;">
                            <!-- Symbol progress cards will be inserted here -->
                        </div>
                    </div>

                    <!-- VM Status Grid -->
                    <div style="margin-bottom: 20px;">
                        <div style="font-size: 14px; font-weight: 600; margin-bottom: 8px;">VM Status</div>
                        <div id="orchestrator-vm-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px;">
                            <!-- VM cards will be inserted here -->
                        </div>
                    </div>

                    <!-- Job Queue Table -->
                    <div style="flex: 1; min-height: 300px; display: flex; flex-direction: column;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <div style="font-size: 14px; font-weight: 600;">Job Queue</div>
                            <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                                <select id="orchestrator-filter-status" onchange="orchestratorApplyFilter()" style="font-size: 12px;">
                                    <option value="">All Status</option>
                                    <option value="pending">Pending</option>
                                    <option value="running">Running</option>
                                    <option value="completed">Completed</option>
                                    <option value="failed">Failed</option>
                                </select>
                                <select id="orchestrator-filter-symbol" onchange="orchestratorApplyFilter()" style="font-size: 12px;">
                                    <option value="">All Symbols</option>
                                    <option value="EURCAD">EURCAD</option>
                                    <option value="EURGBP">EURGBP</option>
                                    <option value="EURJPY">EURJPY</option>
                                    <option value="EURUSD">EURUSD</option>
                                    <option value="GBPUSD">GBPUSD</option>
                                    <option value="USDCAD">USDCAD</option>
                                    <option value="USDCHF">USDCHF</option>
                                    <option value="USDJPY">USDJPY</option>
                                </select>
                                <select id="orchestrator-filter-direction" onchange="orchestratorApplyFilter()" style="font-size: 12px;">
                                    <option value="">All Directions</option>
                                    <option value="long">Long</option>
                                    <option value="short">Short</option>
                                </select>
                                <select id="orchestrator-filter-timeframe" onchange="orchestratorApplyFilter()" style="font-size: 12px;">
                                    <option value="">All TF</option>
                                    <option value="M15">M15</option>
                                    <option value="M30">M30</option>
                                    <option value="H1">H1</option>
                                    <option value="H3">H3</option>
                                    <option value="H4">H4</option>
                                    <option value="D1">D1</option>
                                </select>
                                <select id="orchestrator-filter-phase5" onchange="orchestratorApplyFilter()" style="font-size: 12px;">
                                    <option value="">All Phase 5</option>
                                    <option value="true">Passed</option>
                                    <option value="false">Failed</option>
                                </select>
                                <select id="orchestrator-filter-vm" onchange="orchestratorApplyFilter()" style="font-size: 12px;">
                                    <option value="">All VMs</option>
                                    <option value="contabo-01">contabo-01</option>
                                    <option value="contabo-02">contabo-02</option>
                                    <option value="wsl-local">wsl-local</option>
                                </select>
                            </div>
                        </div>
                        <div class="trades-table-container" style="flex: 1;">
                            <table class="trades-table">
                                <thead id="orchestratorJobsHead">
                                    <tr>
                                        <th>Signal</th>
                                        <th>Symbol</th>
                                        <th>Direction</th>
                                        <th>TF</th>
                                        <th>Trades</th>
                                        <th>Status</th>
                                        <th>Phase 5</th>
                                        <th>PF</th>
                                        <th>WR</th>
                                        <th>VM</th>
                                        <th>Completed</th>
                                    </tr>
                                </thead>
                                <tbody id="orchestratorJobsBody">
                                    <tr><td colspan="11" style="text-align: center; padding: 40px;">Loading jobs...</td></tr>
                                </tbody>
                            </table>
                        </div>
                        <!-- Pagination -->
                        <div id="orchestrator-pagination" style="display: flex; justify-content: center; gap: 8px; margin-top: 12px;">
                            <!-- Pagination buttons will be inserted here -->
                        </div>
                    </div>
                </div>
            </div>


            <div id="decisionsView" class="hidden">
                <div class="card" style="flex: 1; display: flex; flex-direction: column; min-height: 0;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <div class="card-title">Decision Log</div>
                        <div class="status" id="decisionsStatus">Loading...</div>
                    </div>

                    <!-- Summary Cards -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 12px; margin-bottom: 16px;">
                        <div style="background: #f9fafb; padding: 12px; border-radius: 8px; border: 1px solid #e5e7eb;">
                            <div style="font-size: 11px; color: #6b7280;">Total Decisions</div>
                            <div id="dec-total" style="font-size: 20px; font-weight: 600;">-</div>
                        </div>
                        <div style="background: #f9fafb; padding: 12px; border-radius: 8px; border: 1px solid #e5e7eb;">
                            <div style="font-size: 11px; color: #6b7280;">Signals Accepted</div>
                            <div id="dec-accepted" style="font-size: 20px; font-weight: 600; color: #10b981;">-</div>
                        </div>
                        <div style="background: #f9fafb; padding: 12px; border-radius: 8px; border: 1px solid #e5e7eb;">
                            <div style="font-size: 11px; color: #6b7280;">Signals Rejected</div>
                            <div id="dec-rejected" style="font-size: 20px; font-weight: 600; color: #f59e0b;">-</div>
                        </div>
                        <div style="background: #f9fafb; padding: 12px; border-radius: 8px; border: 1px solid #e5e7eb;">
                            <div style="font-size: 11px; color: #6b7280;">RL Exits (CLOSE/HOLD)</div>
                            <div id="dec-rl-exits" style="font-size: 20px; font-weight: 600; color: #3b82f6;">-</div>
                        </div>
                    </div>

                    <!-- Filter Bar -->
                    <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 12px; align-items: center;">
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <label style="font-size: 11px; color: #6b7280; font-weight: 600;">Type:</label>
                            <select id="decFilterType" style="padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 12px;" onchange="loadDecisions()">
                                <option value="">All</option>
                                <option value="signal_generated">Signal Generated</option>
                                <option value="signal_rejected">Signal Rejected</option>
                                <option value="position_opened">Position Opened</option>
                                <option value="position_closed">Position Closed</option>
                                <option value="rl_exit_decision">RL Exit Decision</option>
                                <option value="risk_violation">Risk Violation</option>
                                <option value="system_error">System Error</option>
                                <option value="symbol_disabled">Symbol Disabled</option>
                            </select>
                        </div>
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <label style="font-size: 11px; color: #6b7280; font-weight: 600;">Symbol:</label>
                            <select id="decFilterSymbol" style="padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 12px;" onchange="loadDecisions()">
                                <option value="">All</option>
                                <option value="EURUSD">EURUSD</option>
                                <option value="GBPUSD">GBPUSD</option>
                                <option value="USDJPY">USDJPY</option>
                                <option value="EURJPY">EURJPY</option>
                                <option value="USDCAD">USDCAD</option>
                                <option value="EURCAD">EURCAD</option>
                                <option value="USDCHF">USDCHF</option>
                                <option value="EURGBP">EURGBP</option>
                            </select>
                        </div>
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <label style="font-size: 11px; color: #6b7280; font-weight: 600;">Dir:</label>
                            <select id="decFilterDir" style="padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 12px;" onchange="loadDecisions()">
                                <option value="">All</option>
                                <option value="LONG">LONG</option>
                                <option value="SHORT">SHORT</option>
                            </select>
                        </div>
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <label style="font-size: 11px; color: #6b7280; font-weight: 600;">Limit:</label>
                            <select id="decFilterLimit" style="padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 12px;" onchange="loadDecisions()">
                                <option value="50">50</option>
                                <option value="100">100</option>
                                <option value="200">200</option>
                                <option value="500" selected>500</option>
                            </select>
                        </div>
                        <button onclick="loadDecisions()" style="padding: 4px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 12px; background: #f9fafb; cursor: pointer;">Refresh</button>
                        <span id="decFilterCount" style="font-size: 11px; color: #6b7280; margin-left: auto;"></span>
                    </div>

                    <!-- Decisions Table -->
                    <div class="trades-table-container" style="flex: 1; min-height: 300px;">
                        <table class="trades-table">
                            <thead>
                                <tr>
                                    <th>Time</th>
                                    <th>Type</th>
                                    <th>Symbol</th>
                                    <th>Dir</th>
                                    <th>Action</th>
                                    <th>Close %</th>
                                    <th>Votes</th>
                                    <th>P&L</th>
                                    <th>Details</th>
                                </tr>
                            </thead>
                            <tbody id="decisionsBody">
                                <tr><td colspan="9" style="text-align: center; padding: 40px;">Loading decisions...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = '/api';
        let currentView = 'charts';
        let candleCountdownInterval;
        let refreshInterval;

        // Position overlay colors (for future use)
        const POSITION_COLORS = {
            negative: '#fab7bc',  // Negative pips
            positive: '#ceebe6'   // Positive pips
        };

        // Format date as DD-MM-YYYY HH:MM:SS (24h format)
        function formatDateTime(date) {
            const d = new Date(date);
            const day = String(d.getDate()).padStart(2, '0');
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const year = d.getFullYear();
            const hours = String(d.getHours()).padStart(2, '0');
            const minutes = String(d.getMinutes()).padStart(2, '0');
            const seconds = String(d.getSeconds()).padStart(2, '0');
            return `${day}-${month}-${year} ${hours}:${minutes}:${seconds}`;
        }

        // MT5 broker (OANDATMS) stores timestamps in CET/CEST, not UTC.
        // Verified 2026-02-25: broker offset is exactly +3600s (1h) from UTC in winter.
        // CET = UTC+1 (Nov-Feb), CEST = UTC+2 (Apr-Sep).
        // Transitions: last Sunday of March (‚ÜíCEST) and last Sunday of October (‚ÜíCET).
        function getBrokerUtcOffsetMs(timestampMs) {
            const d = new Date(timestampMs);
            const month = d.getUTCMonth(); // 0-indexed
            if (month >= 10 || month <= 1) return 3600000;   // Nov-Feb: CET (UTC+1)
            if (month >= 3 && month <= 8) return 7200000;    // Apr-Sep: CEST (UTC+2)
            // March (2) or October (9): check exact transition
            const year = d.getUTCFullYear();
            const lastDay = new Date(Date.UTC(year, month + 1, 0));
            const lastSunday = new Date(Date.UTC(year, month, lastDay.getUTCDate() - lastDay.getUTCDay()));
            lastSunday.setUTCHours(1, 0, 0, 0); // Transition at 01:00 UTC
            if (month === 2) return timestampMs >= lastSunday.getTime() ? 7200000 : 3600000;
            return timestampMs >= lastSunday.getTime() ? 3600000 : 7200000; // October
        }

        function brokerToUTC(timestampMs) {
            return timestampMs - getBrokerUtcOffsetMs(timestampMs);
        }

        function showView(view) {
            currentView = view;
            document.getElementById('chartsView').classList.toggle('hidden', view !== 'charts');
            document.getElementById('paperView').classList.toggle('hidden', view !== 'paper');
            document.getElementById('orchestratorView').classList.toggle('hidden', view !== 'orchestrator');
            document.getElementById('decisionsView').classList.toggle('hidden', view !== 'decisions');
            document.getElementById('chartControls').classList.toggle('hidden', view !== 'charts');
            document.getElementById('modelInfoCard').classList.toggle('hidden', view !== 'charts');
            document.getElementById('paperTradingModels').classList.toggle('hidden', view !== 'paper');

            document.querySelectorAll('.nav-button').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            clearInterval(refreshInterval);
            clearInterval(candleCountdownInterval);
            if (view === 'charts') {
                loadData();
                updateModelInfoCard();
                refreshInterval = setInterval(loadData, 60000);
            } else if (view === 'paper') {
                loadTrades();
                updateSidebarModels();
                refreshInterval = setInterval(() => {
                    loadTrades();
                    updateSidebarModels();
                }, 60000);
            } else if (view === 'orchestrator') {
                loadOrchestratorData();
                refreshInterval = setInterval(loadOrchestratorData, 10000);
            } else if (view === 'decisions') {
                loadDecisions();
                refreshInterval = setInterval(loadDecisions, 600000);
            }
        }

        // Calculate date range based on timeframe to get ~1000 candles
        function getDateRangeForTimeframe(timeframe) {
            const now = Date.now();
            // Extend end by broker offset so query covers broker-time epochs (CET/CEST)
            const end = new Date(now + getBrokerUtcOffsetMs(now));
            let start;

            // Calculate start date to get approximately 1000 candles
            // Add extra buffer to account for weekends/holidays
            const timeframeMinutes = {
                'M10': 10,
                'M20': 20,
                'M30': 30,
                'H1': 60,
                'H2': 120,
                'H3': 180,
                'H4': 240,
                'H6': 360,
                'H8': 480,
                'H12': 720,
                'D1': 1440
            };

            const minutes = timeframeMinutes[timeframe] || 60;
            const targetCandles = 1000;

            // Larger buffer for intraday timeframes due to market hours
            let bufferMultiplier;
            if (minutes <= 20) {
                bufferMultiplier = 4.0; // M10, M20 need 4x buffer (24/6 market hours)
            } else if (minutes <= 180) {
                bufferMultiplier = 2.5; // M30, H1, H2, H3 need 2.5x buffer
            } else {
                bufferMultiplier = 1.5; // H4, H6, H8, H12, D1 need 1.5x buffer
            }

            const millisecondsNeeded = targetCandles * minutes * 60 * 1000 * bufferMultiplier;
            start = new Date(now - millisecondsNeeded);

            return {
                start: start.toISOString(),
                end: end.toISOString()
            };
        }

        async function loadData() {
            const symbol = document.getElementById('symbol').value;
            const timeframe = document.getElementById('timeframe').value;
            const candleLimit = parseInt(document.getElementById('candleLimit').value);
            const status = document.getElementById('status');

            status.className = 'status loading';
            status.textContent = 'üü° Loading...';

            try {
                const { start, end } = getDateRangeForTimeframe(timeframe);

                // Request candles based on user selection
                const response = await fetch(`${API_BASE}/markets/${symbol}/${timeframe}?start=${start}&end=${end}&limit=${candleLimit}`);
                if (!response.ok) throw new Error('API request failed');

                const result = await response.json();
                let data = result.data || result; // Handle both response formats

                if (!data || data.length === 0) {
                    throw new Error('No data available');
                }

                // Filter out invalid/placeholder candles using statistical outlier detection
                const isJPYPair = symbol.includes('JPY');
                const originalLength = data.length;

                // First pass: get price distribution from the last 80% of candles (most likely valid)
                const sampleSize = Math.floor(data.length * 0.8);
                const samplePrices = data.slice(-sampleSize).map(c => c.close || c.open).filter(p => p > 0);
                const medianPrice = samplePrices.sort((a, b) => a - b)[Math.floor(samplePrices.length / 2)] || 1;

                data = data.filter(candle => {
                    const price = candle.close || candle.open;

                    // Detect placeholder candles - they have suspiciously exact/round values around 1.1
                    // Pattern: O=1.1, H=1.105, L=1.095, C=1.102 (or slight variants)
                    // These exact values never occur in real forex data
                    const isPlaceholder = (
                        (Math.abs(candle.open - 1.1) < 0.01 && Math.abs(candle.low - 1.095) < 0.01) ||
                        (Math.abs(candle.open - 1.1002) < 0.001 && Math.abs(candle.close - 1.1002) < 0.001) ||
                        (candle.open >= 1.09 && candle.open <= 1.11 &&
                         candle.high >= 1.09 && candle.high <= 1.11 &&
                         candle.low >= 1.09 && candle.low <= 1.10 &&
                         candle.close >= 1.09 && candle.close <= 1.11)
                    );

                    // Filter out placeholder candles unconditionally - they're never real data
                    if (isPlaceholder) {
                        return false;
                    }

                    // Symbol-specific price range validation
                    if (isJPYPair) {
                        return price > 50;
                    } else if (symbol.includes('XAU')) {
                        return price > 1000;
                    } else if (symbol.includes('XAG')) {
                        return price > 10;
                    } else if (symbol.includes('BTC')) {
                        return price > 1000;
                    } else {
                        return price > 0.5 && price < 50;
                    }
                });

                if (data.length < originalLength) {
                    console.warn(`‚ö†Ô∏è Filtered out ${originalLength - data.length} invalid candles`);
                }

                if (data.length === 0) {
                    throw new Error('No valid data after filtering');
                }

                // Pass candleLimit to plotChart for initial display range
                plotChart(data, symbol, timeframe, candleLimit);

                status.className = 'status connected';
                const formattedTime = formatDateTime(new Date());
                status.textContent = `üü¢ Connected | ${data.length} candles | Updated: ${formattedTime}`;
            } catch (error) {
                status.className = 'status error';
                status.textContent = 'üî¥ Error: ' + error.message;
                console.error('Error loading data:', error);
            }
        }

        async function fetchOBBBlocks(symbol, timeframe, start, end) {
            try {
                // Fetch from ai_model database order_blocks table
                // Convert symbol to match backend format (EURUSD instead of EUR/USD)
                const backendSymbol = symbol.replace('/', '');
                const response = await fetch(`${API_BASE}/ai-model/order-blocks/${backendSymbol}/${timeframe}?start=${start}&end=${end}&limit=1000`);
                if (!response.ok) {
                    console.warn('OBB blocks not available:', response.status);
                    return [];
                }
                const result = await response.json();
                return result.data || [];
            } catch (error) {
                console.warn('OBB blocks not available:', error);
                return [];
            }
        }

        async function fetchOpenPositions(symbol) {
            try {
                // Fetch open positions from paper trading API
                const response = await fetch(`${API_BASE}/paper-trading/positions`);
                if (!response.ok) {
                    console.warn('Positions not available:', response.status);
                    return [];
                }
                const result = await response.json();
                const positions = (result.data || []).map(p => ({...p, direction: (p.direction || '').toLowerCase()}));

                // Filter positions for current symbol (EURUSD matches EUR/USD)
                const backendSymbol = symbol.replace('/', '');
                return positions.filter(pos => pos.symbol === backendSymbol);
            } catch (error) {
                console.warn('Positions not available:', error);
                return [];
            }
        }

        // Build position entry/SL/TP shapes and annotations
        // Lines start from entry candle, not full chart width
        function buildPositionMarkers(positions, priceDecimals, timestamps) {
            const shapes = [];
            const annotations = [];
            // Calculate line end: last candle + a few candle widths so line reaches right margin
            const lastTime = timestamps[0];
            const candleMs = timestamps.length > 1 ? (timestamps[0] - timestamps[1]) : 3600000;
            const lineEnd = new Date(lastTime.getTime() + candleMs * 5);

            for (const pos of positions) {
                const isLong = pos.direction === 'long';
                const color = isLong ? '#10b981' : '#ef4444';
                const entryPrice = parseFloat(pos.entry_price);
                if (isNaN(entryPrice)) continue;
                const entryTime = new Date(pos.opened_at);
                const label = isLong ? 'L' : 'S';

                // Entry price line (from entry candle to right edge) + badge
                shapes.push({
                    type: 'line', xref: 'x', yref: 'y',
                    x0: entryTime, x1: lineEnd, y0: entryPrice, y1: entryPrice,
                    line: { color, width: 1, dash: 'dot' },
                    layer: 'above'
                });
                annotations.push({
                    x: 1.0, xref: 'paper', y: entryPrice, yref: 'y',
                    text: ` ${label} ${entryPrice.toFixed(priceDecimals)} `,
                    showarrow: false,
                    font: { size: 11, color: '#ffffff', family: 'Consolas, monospace' },
                    bgcolor: color, borderpad: 3, bordercolor: color,
                    xanchor: 'left'
                });

                // Calculate SL/TP absolute prices from pip offsets
                // API returns sl_pips/tp_pips (offsets), not sl_price/tp_price
                const isJPY = pos.symbol && pos.symbol.toUpperCase().includes('JPY');
                const pipSize = isJPY ? 0.01 : 0.0001;
                const slPips = parseFloat(pos.sl_pips);
                const tpPips = parseFloat(pos.tp_pips);

                // SL line + badge + shaded zone
                if (!isNaN(slPips) && slPips > 0) {
                    const slPrice = isLong
                        ? entryPrice - slPips * pipSize
                        : entryPrice + slPips * pipSize;
                    // Red shaded zone: entry ‚Üí SL
                    shapes.push({
                        type: 'rect', xref: 'x', yref: 'y',
                        x0: entryTime, x1: lineEnd,
                        y0: entryPrice, y1: slPrice,
                        fillcolor: 'rgba(239,68,68,0.08)',
                        line: { width: 0 },
                        layer: 'below'
                    });
                    shapes.push({
                        type: 'line', xref: 'x', yref: 'y',
                        x0: entryTime, x1: lineEnd, y0: slPrice, y1: slPrice,
                        line: { color: '#ef4444', width: 1, dash: 'dot' },
                        layer: 'above'
                    });
                }

                // TP line + badge + shaded zone
                if (!isNaN(tpPips) && tpPips > 0) {
                    const tpPrice = isLong
                        ? entryPrice + tpPips * pipSize
                        : entryPrice - tpPips * pipSize;
                    // Green shaded zone: entry ‚Üí TP
                    shapes.push({
                        type: 'rect', xref: 'x', yref: 'y',
                        x0: entryTime, x1: lineEnd,
                        y0: entryPrice, y1: tpPrice,
                        fillcolor: 'rgba(16,185,129,0.08)',
                        line: { width: 0 },
                        layer: 'below'
                    });
                    shapes.push({
                        type: 'line', xref: 'x', yref: 'y',
                        x0: entryTime, x1: lineEnd, y0: tpPrice, y1: tpPrice,
                        line: { color: '#10b981', width: 1, dash: 'dot' },
                        layer: 'above'
                    });
                }
            }
            return { shapes, annotations };
        }

        // Detect overlapping right-margin badges and shift them apart
        function deOverlapBadges(annotations) {
            // Sort by Y value
            const sorted = annotations
                .map((a, i) => ({ ann: a, idx: i, y: a.y }))
                .sort((a, b) => a.y - b.y);

            // Check adjacent pairs; if too close, apply yshift to push apart
            // Badge height ~20px, threshold in price units depends on chart scale
            // Use pixel-based yshift instead: detect closeness relative to price range
            const chartDiv = document.getElementById('chart');
            const yRange = chartDiv && chartDiv.layout && chartDiv.layout.yaxis
                ? (chartDiv.layout.yaxis.range || [0, 1]) : null;
            const plotHeight = chartDiv ? chartDiv.clientHeight * 0.8 : 600; // approx plot area
            const badgePx = 22; // badge height in pixels

            for (let i = 1; i < sorted.length; i++) {
                const prev = sorted[i - 1];
                const curr = sorted[i];
                if (yRange) {
                    const pricePerPx = (yRange[1] - yRange[0]) / plotHeight;
                    const gapPrice = curr.y - prev.y;
                    const gapPx = gapPrice / pricePerPx;
                    if (Math.abs(gapPx) < badgePx) {
                        // Shift apart: move prev down, curr up
                        const shiftNeeded = Math.ceil((badgePx - Math.abs(gapPx)) / 2) + 2;
                        prev.ann.yshift = (prev.ann.yshift || 0) - shiftNeeded;
                        curr.ann.yshift = (curr.ann.yshift || 0) + shiftNeeded;
                    }
                } else {
                    // Fallback: if Y values within 0.00020 (2 pips), shift
                    if (Math.abs(curr.y - prev.y) < 0.00020) {
                        prev.ann.yshift = (prev.ann.yshift || 0) - 12;
                        curr.ann.yshift = (curr.ann.yshift || 0) + 12;
                    }
                }
            }
            return annotations;
        }

        function plotChart(data, symbol, timeframe, candleLimit = 300) {
            // Debug: log first and last data points to verify correct symbol data
            console.log(`üìä plotChart called for ${symbol} with ${data.length} candles`);
            if (data.length > 0) {
                console.log(`   First candle: ${data[0].timestamp} - O:${data[0].open} H:${data[0].high} L:${data[0].low} C:${data[0].close}`);
                console.log(`   Last candle: ${data[data.length-1].timestamp} - O:${data[data.length-1].open} H:${data[data.length-1].high} L:${data[data.length-1].low} C:${data[data.length-1].close}`);
            }

            const timestamps = data.map(d => new Date(brokerToUTC(d.timestamp)));

            // Get indicator checkbox states
            const showSMA20 = document.getElementById('showSMA20').checked;
            const showSMA50 = document.getElementById('showSMA50').checked;
            const showSMA200 = document.getElementById('showSMA200').checked;
            const showEMA12 = document.getElementById('showEMA12').checked;
            const showEMA26 = document.getElementById('showEMA26').checked;
            const showEMA50 = document.getElementById('showEMA50').checked;
            const showBB = document.getElementById('showBB').checked;
            const showATRBands = document.getElementById('showATRBands').checked;
            const showOBB = document.getElementById('showOBB').checked;
            const showVolume = document.getElementById('showVolume').checked;
            const showRSI = document.getElementById('showRSI').checked;
            const showMACD = document.getElementById('showMACD').checked;
            const showStochastic = document.getElementById('showStochastic').checked;
            const showATR = document.getElementById('showATR').checked;

            // Count oscillators to determine layout
            const oscillators = [];
            if (showVolume) oscillators.push('Volume');
            if (showRSI) oscillators.push('RSI');
            if (showMACD) oscillators.push('MACD');
            if (showStochastic) oscillators.push('Stochastic');
            if (showATR) oscillators.push('ATR');

            // Calculate subplot heights
            let mainHeight, oscHeight;
            if (oscillators.length === 0) {
                mainHeight = [0, 1];
            } else if (oscillators.length === 1) {
                mainHeight = [0.25, 1];
                oscHeight = [[0, 0.20]];
            } else if (oscillators.length === 2) {
                mainHeight = [0.35, 1];
                oscHeight = [[0.175, 0.325], [0, 0.15]];
            } else if (oscillators.length === 3) {
                mainHeight = [0.40, 1];
                oscHeight = [[0.26, 0.38], [0.13, 0.25], [0, 0.12]];
            } else if (oscillators.length === 4) {
                mainHeight = [0.45, 1];
                oscHeight = [[0.33, 0.43], [0.22, 0.32], [0.11, 0.21], [0, 0.10]];
            } else { // 5 oscillators
                mainHeight = [0.50, 1];
                oscHeight = [[0.38, 0.48], [0.29, 0.37], [0.19, 0.28], [0.10, 0.18], [0, 0.09]];
            }

            // Main candlestick chart
            const candlestick = {
                x: timestamps,
                open: data.map(d => d.open),
                high: data.map(d => d.high),
                low: data.map(d => d.low),
                close: data.map(d => d.close),
                type: 'candlestick',
                name: symbol,
                xaxis: 'x',
                yaxis: 'y',
                increasing: {
                    line: {color: '#9c9c9c', width: 1},
                    fillcolor: '#e8eaee'
                },
                decreasing: {
                    line: {color: '#7b7c80', width: 1},
                    fillcolor: '#8f9197'
                },
                whiskerwidth: 0.5,
                hovertemplate: '<b>%{x} UTC</b><br>' +
                               'Open: %{open:.5f}<br>' +
                               'High: %{high:.5f}<br>' +
                               'Low: %{low:.5f}<br>' +
                               'Close: %{close:.5f}<br>' +
                               '<extra></extra>'
            };

            const traces = [candlestick];

            // Add overlay indicators if available
            // Use a sample row that has indicator data (latest candle may still be forming)
            const sampleRow = data.find(d => d.indicators && Object.keys(d.indicators).length > 0);
            if (sampleRow) {
                const indicators = sampleRow.indicators;

                // SMA20
                if (showSMA20 && indicators.sma_20 !== undefined) {
                    traces.push({
                        x: timestamps,
                        y: data.map(d => parseFloat(d.indicators.sma_20)),
                        type: 'scatter',
                        mode: 'lines',
                        name: 'SMA20',
                        xaxis: 'x',
                        yaxis: 'y',
                        line: {color: '#ffac59', width: 1.5}
                    });
                }

                // SMA50
                if (showSMA50 && indicators.sma_50 !== undefined) {
                    traces.push({
                        x: timestamps,
                        y: data.map(d => parseFloat(d.indicators.sma_50)),
                        type: 'scatter',
                        mode: 'lines',
                        name: 'SMA50',
                        xaxis: 'x',
                        yaxis: 'y',
                        line: {color: '#5a5aff', width: 1.5}
                    });
                }

                // SMA200
                if (showSMA200 && indicators.sma_200 !== undefined) {
                    traces.push({
                        x: timestamps,
                        y: data.map(d => parseFloat(d.indicators.sma_200)),
                        type: 'scatter',
                        mode: 'lines',
                        name: 'SMA200',
                        xaxis: 'x',
                        yaxis: 'y',
                        line: {color: '#ff1744', width: 2}
                    });
                }

                // EMA12
                if (showEMA12 && indicators.ema_12 !== undefined) {
                    traces.push({
                        x: timestamps,
                        y: data.map(d => parseFloat(d.indicators.ema_12)),
                        type: 'scatter',
                        mode: 'lines',
                        name: 'EMA12',
                        xaxis: 'x',
                        yaxis: 'y',
                        line: {color: '#ff6b9d', width: 1.5}
                    });
                }

                // EMA26
                if (showEMA26 && indicators.ema_26 !== undefined) {
                    traces.push({
                        x: timestamps,
                        y: data.map(d => parseFloat(d.indicators.ema_26)),
                        type: 'scatter',
                        mode: 'lines',
                        name: 'EMA26',
                        xaxis: 'x',
                        yaxis: 'y',
                        line: {color: '#ab47bc', width: 1.5}
                    });
                }

                // EMA50
                if (showEMA50 && indicators.ema_50 !== undefined) {
                    traces.push({
                        x: timestamps,
                        y: data.map(d => parseFloat(d.indicators.ema_50)),
                        type: 'scatter',
                        mode: 'lines',
                        name: 'EMA50',
                        xaxis: 'x',
                        yaxis: 'y',
                        line: {color: '#9d50bb', width: 1.5}
                    });
                }

                // Bollinger Bands - with data validation
                if (showBB && indicators.bb_upper_20 !== undefined) {
                    const bbUpper = data.map(d => {
                        const val = parseFloat(d.indicators.bb_upper_20);
                        return isNaN(val) || !isFinite(val) ? null : val;
                    });
                    const bbLower = data.map(d => {
                        const val = parseFloat(d.indicators.bb_lower_20);
                        return isNaN(val) || !isFinite(val) ? null : val;
                    });

                    traces.push({
                        x: timestamps,
                        y: bbUpper,
                        type: 'scatter',
                        mode: 'lines',
                        name: 'BB Upper',
                        xaxis: 'x',
                        yaxis: 'y',
                        line: {color: '#00bfff', width: 1, dash: 'dot'},
                        connectgaps: false
                    });

                    traces.push({
                        x: timestamps,
                        y: bbLower,
                        type: 'scatter',
                        mode: 'lines',
                        name: 'BB Lower',
                        xaxis: 'x',
                        yaxis: 'y',
                        line: {color: '#00bfff', width: 1, dash: 'dot'},
                        fill: 'tonexty',
                        fillcolor: 'rgba(0, 191, 255, 0.05)',
                        connectgaps: false
                    });
                }

                // ATR Bands (for visualizing ATR breakout signals)
                if (showATRBands && indicators.atr_14 !== undefined && indicators.sma_20 !== undefined) {
                    const atrMultiplier = 1.5; // Common breakout multiplier

                    const atrUpper = data.map(d => {
                        const sma = parseFloat(d.indicators.sma_20);
                        const atr = parseFloat(d.indicators.atr_14);
                        const val = sma + (atr * atrMultiplier);
                        return isNaN(val) || !isFinite(val) ? null : val;
                    });

                    const atrLower = data.map(d => {
                        const sma = parseFloat(d.indicators.sma_20);
                        const atr = parseFloat(d.indicators.atr_14);
                        const val = sma - (atr * atrMultiplier);
                        return isNaN(val) || !isFinite(val) ? null : val;
                    });

                    traces.push({
                        x: timestamps,
                        y: atrUpper,
                        type: 'scatter',
                        mode: 'lines',
                        name: 'ATR Upper (breakout)',
                        xaxis: 'x',
                        yaxis: 'y',
                        line: {color: '#ff6b6b', width: 1.5, dash: 'dash'},
                        connectgaps: false
                    });

                    traces.push({
                        x: timestamps,
                        y: atrLower,
                        type: 'scatter',
                        mode: 'lines',
                        name: 'ATR Lower (breakout)',
                        xaxis: 'x',
                        yaxis: 'y',
                        line: {color: '#ff6b6b', width: 1.5, dash: 'dash'},
                        fill: 'tonexty',
                        fillcolor: 'rgba(255, 107, 107, 0.08)',
                        connectgaps: false
                    });
                }

                // OBB Blocks from AI model (render using Plotly shapes with horizontal projection)
                if (showOBB) {
                    // Calculate wider date range for OBs (same as market data - ~1000 candles with buffer)
                    const { start, end } = getDateRangeForTimeframe(timeframe);

                    // Fetch OBB blocks asynchronously using wide date range
                    fetchOBBBlocks(symbol, timeframe, start, end)
                        .then(obbBlocks => {
                            if (obbBlocks.length > 0) {
                                console.log('Rendering', obbBlocks.length, 'order blocks');

                                // Get last timestamp for horizontal projection
                                const lastTimestamp = timestamps[0]; // Newest candle (data is DESC)

                                // Sort OBs by timestamp descending (newest first)
                                const sortedOBs = [...obbBlocks].sort((a, b) => b.ts - a.ts);

                                // Find LATEST bullish and bearish OBs only
                                const latestBullishOB = sortedOBs.find(ob => ob.direction === 'BULLISH');
                                const latestBearishOB = sortedOBs.find(ob => ob.direction === 'BEARISH');

                                // Count active vs inactive for status display
                                const activeOBs = obbBlocks.filter(ob => ob.status === 'ACTIVE');
                                console.log(`Total OBs: ${obbBlocks.length}, Active: ${activeOBs.length}`);
                                console.log('Latest Bullish OB:', latestBullishOB);
                                console.log('Latest Bearish OB:', latestBearishOB);

                                // Create shapes array for OB visualization
                                const obShapes = [];

                                // Helper to create OB shapes with horizontal projection
                                const createOBShapes = (ob) => {
                                    if (!ob) return; // Skip if no OB found

                                    const isBullish = ob.direction === 'BULLISH';
                                    const isActive = ob.status === 'ACTIVE';
                                    const baseColor = isBullish
                                        ? 'rgba(34, 197, 94' // Green
                                        : 'rgba(239, 68, 68'; // Red

                                    // Use higher opacity for active OBs
                                    const fillOpacity = isActive ? '0.2' : '0.15';
                                    const borderOpacity = isActive ? '0.8' : '0.5';

                                    const fillColor = `${baseColor}, ${fillOpacity})`;
                                    const borderColor = `${baseColor}, ${borderOpacity})`;

                                    const obStartTime = new Date(ob.ts);

                                    // 1. Horizontal projection rectangle (from OB timestamp to last candle)
                                    obShapes.push({
                                        type: 'rect',
                                        xref: 'x',
                                        yref: 'y',
                                        x0: obStartTime,
                                        x1: lastTimestamp,  // Extend to newest candle (horizontal projection)
                                        y0: ob.obLow,
                                        y1: ob.obHigh,
                                        fillcolor: fillColor,
                                        line: {
                                            color: borderColor,
                                            width: 1,
                                            dash: 'dot'  // Dashed border
                                        },
                                        layer: 'below'  // Draw below candles
                                    });

                                    // 2. Vertical line at OB start (solid, thicker)
                                    obShapes.push({
                                        type: 'line',
                                        xref: 'x',
                                        yref: 'y',
                                        x0: obStartTime,
                                        x1: obStartTime,
                                        y0: ob.obLow,
                                        y1: ob.obHigh,
                                        line: {
                                            color: borderColor,
                                            width: 2  // Thicker line at start
                                        },
                                        layer: 'below'
                                    });
                                };

                                // Render ONLY the latest bullish and bearish OBs
                                createOBShapes(latestBullishOB);
                                createOBShapes(latestBearishOB);

                                console.log(`Created ${obShapes.length} OB shapes (${obShapes.length/2} blocks total)`);

                                // Fetch and add position markers
                                fetchOpenPositions(symbol).then(positions => {
                                    console.log('Fetched', positions.length, 'open positions for', symbol);

                                    // Build position entry/SL/TP shapes and badges
                                    const { shapes: positionShapes, annotations: positionAnnotations } =
                                        buildPositionMarkers(positions, priceDecimals, timestamps);

                                    // Combine current price line, OB shapes, and position markers
                                    const allShapes = [currentPriceShape, ...obShapes, ...positionShapes];
                                    const allAnnotations = deOverlapBadges([currentPriceAnnotation, ...positionAnnotations]);

                                    // Update chart with shapes (single relayout call)
                                    console.log('Adding', allShapes.length, 'shapes to chart');
                                    Plotly.relayout('chart', { shapes: allShapes, annotations: allAnnotations })
                                        .then(() => console.log('OB shapes and position markers added'))
                                        .catch(err => console.error('Failed to add shapes:', err));

                                    // Update OBB status message
                                    const statusDiv = document.getElementById('obbStatus');
                                    const bullishCount = obbBlocks.filter(b => b.direction === 'BULLISH').length;
                                    const bearishCount = obbBlocks.filter(b => b.direction === 'BEARISH').length;
                                    const activeCount = activeOBs.length;
                                    const mitigatedCount = obbBlocks.filter(b => b.status === 'MITIGATED').length;
                                    const invalidatedCount = obbBlocks.filter(b => b.status === 'INVALIDATED').length;

                                    statusDiv.textContent = `${obbBlocks.length} OBs (${bullishCount} bullish, ${bearishCount} bearish) | ${activeCount} active, ${mitigatedCount} mitigated, ${invalidatedCount} invalidated`;
                                    statusDiv.style.display = 'block';
                                    statusDiv.style.color = activeCount > 0 ? '#10b981' : '#6b7280';
                                }).catch(error => console.error('Error fetching positions:', error));
                            } else {
                                // No OBs found - still show position markers
                                fetchOpenPositions(symbol).then(positions => {
                                    const { shapes: positionShapes, annotations: positionAnnotations } =
                                        buildPositionMarkers(positions, priceDecimals, timestamps);
                                    const allShapes = [currentPriceShape, ...positionShapes];
                                    const allAnnotations = deOverlapBadges([currentPriceAnnotation, ...positionAnnotations]);
                                    Plotly.relayout('chart', { shapes: allShapes, annotations: allAnnotations });
                                }).catch(() => {
                                    Plotly.relayout('chart', { shapes: [currentPriceShape], annotations: [currentPriceAnnotation] });
                                });
                                const statusDiv = document.getElementById('obbStatus');
                                statusDiv.textContent = 'No order blocks found';
                                statusDiv.style.display = 'block';
                                statusDiv.style.color = '#f59e0b';
                            }
                        })
                        .catch(error => console.error('Error rendering OBB blocks:', error));
                } else {
                    // If OBB blocks not enabled, hide status message and still show position markers
                    document.getElementById('obbStatus').style.display = 'none';

                    fetchOpenPositions(symbol).then(positions => {
                        console.log('Fetched', positions.length, 'open positions for', symbol);

                        const { shapes: positionShapes, annotations: positionAnnotations } =
                            buildPositionMarkers(positions, priceDecimals, timestamps);

                        const allShapes = [currentPriceShape, ...positionShapes];
                        const allAnnotations = deOverlapBadges([currentPriceAnnotation, ...positionAnnotations]);
                        Plotly.relayout('chart', { shapes: allShapes, annotations: allAnnotations })
                            .then(() => console.log('Position markers applied to chart'))
                            .catch(err => console.error('Failed to apply position markers:', err));
                    }).catch(error => console.error('Error fetching positions:', error));
                }

                // Add oscillator traces
                let oscIndex = 0;

                // Volume - always available from candle data
                if (showVolume) {
                    const yaxis = `y${oscIndex + 2}`;
                    const volumes = data.map(d => d.volume);
                    const volumeColors = data.map((d, i) => {
                        if (i === 0) return '#9e9e9e';
                        return d.close >= data[i-1].close ? '#4caf50' : '#ef4444';
                    });

                    traces.push({
                        x: timestamps,
                        y: volumes,
                        type: 'bar',
                        name: 'Volume',
                        xaxis: 'x',
                        yaxis: yaxis,
                        marker: {color: volumeColors, opacity: 0.5}
                    });
                    oscIndex++;
                }

                // RSI
                if (showRSI && indicators.rsi_14 !== undefined) {
                    const yaxis = `y${oscIndex + 2}`;
                    traces.push({
                        x: timestamps,
                        y: data.map(d => parseFloat(d.indicators.rsi_14)),
                        type: 'scatter',
                        mode: 'lines',
                        name: 'RSI',
                        xaxis: 'x',
                        yaxis: yaxis,
                        line: {color: '#9c27b0', width: 1.5}
                    });
                    // RSI reference lines
                    traces.push({
                        x: [timestamps[0], timestamps[timestamps.length-1]],
                        y: [70, 70],
                        type: 'scatter',
                        mode: 'lines',
                        showlegend: false,
                        xaxis: 'x',
                        yaxis: yaxis,
                        line: {color: '#ff0000', width: 0.5, dash: 'dash'}
                    });
                    traces.push({
                        x: [timestamps[0], timestamps[timestamps.length-1]],
                        y: [30, 30],
                        type: 'scatter',
                        mode: 'lines',
                        showlegend: false,
                        xaxis: 'x',
                        yaxis: yaxis,
                        line: {color: '#00ff00', width: 0.5, dash: 'dash'}
                    });
                    oscIndex++;
                }

                // MACD - with proper data handling
                if (showMACD && (indicators.macd !== undefined || indicators.macd_line !== undefined)) {
                    const yaxis = `y${oscIndex + 2}`;

                    // MACD line (try both field names)
                    const macdValues = data.map(d => {
                        const val = parseFloat(d.indicators.macd || d.indicators.macd_line || 0);
                        return isNaN(val) || !isFinite(val) ? 0 : val;
                    });

                    traces.push({
                        x: timestamps,
                        y: macdValues,
                        type: 'scatter',
                        mode: 'lines',
                        name: 'MACD',
                        xaxis: 'x',
                        yaxis: yaxis,
                        line: {color: '#2196f3', width: 1.5}
                    });

                    // Signal line
                    if (indicators.macd_signal !== undefined || indicators.signal_line !== undefined) {
                        const signalValues = data.map(d => {
                            const val = parseFloat(d.indicators.macd_signal || d.indicators.signal_line || 0);
                            return isNaN(val) || !isFinite(val) ? 0 : val;
                        });

                        traces.push({
                            x: timestamps,
                            y: signalValues,
                            type: 'scatter',
                            mode: 'lines',
                            name: 'Signal',
                            xaxis: 'x',
                            yaxis: yaxis,
                            line: {color: '#ff9800', width: 1.5}
                        });
                    }

                    // Histogram
                    if (indicators.macd_hist !== undefined || indicators.histogram !== undefined) {
                        const histValues = data.map(d => {
                            const val = parseFloat(d.indicators.macd_hist || d.indicators.histogram || 0);
                            return isNaN(val) || !isFinite(val) ? 0 : val;
                        });

                        const histColors = histValues.map(v => v >= 0 ? '#4caf50' : '#ef4444');

                        traces.push({
                            x: timestamps,
                            y: histValues,
                            type: 'bar',
                            name: 'Histogram',
                            xaxis: 'x',
                            yaxis: yaxis,
                            marker: {color: histColors}
                        });
                    }
                    oscIndex++;
                }

                // Stochastic
                if (showStochastic && indicators.stoch_k !== undefined && indicators.stoch_d !== undefined) {
                    const yaxis = `y${oscIndex + 2}`;

                    const stochKValues = data.map(d => {
                        const val = parseFloat(d.indicators.stoch_k);
                        return isNaN(val) || !isFinite(val) ? null : val;
                    });

                    const stochDValues = data.map(d => {
                        const val = parseFloat(d.indicators.stoch_d);
                        return isNaN(val) || !isFinite(val) ? null : val;
                    });

                    traces.push({
                        x: timestamps,
                        y: stochKValues,
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Stoch %K',
                        xaxis: 'x',
                        yaxis: yaxis,
                        line: {color: '#2196f3', width: 1.5}
                    });

                    traces.push({
                        x: timestamps,
                        y: stochDValues,
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Stoch %D',
                        xaxis: 'x',
                        yaxis: yaxis,
                        line: {color: '#ff9800', width: 1.5}
                    });

                    // Stochastic reference lines (overbought/oversold)
                    traces.push({
                        x: [timestamps[0], timestamps[timestamps.length-1]],
                        y: [80, 80],
                        type: 'scatter',
                        mode: 'lines',
                        showlegend: false,
                        xaxis: 'x',
                        yaxis: yaxis,
                        line: {color: '#ff0000', width: 0.5, dash: 'dash'}
                    });

                    traces.push({
                        x: [timestamps[0], timestamps[timestamps.length-1]],
                        y: [20, 20],
                        type: 'scatter',
                        mode: 'lines',
                        showlegend: false,
                        xaxis: 'x',
                        yaxis: yaxis,
                        line: {color: '#00ff00', width: 0.5, dash: 'dash'}
                    });

                    oscIndex++;
                }

                // ATR
                if (showATR && indicators.atr_14 !== undefined) {
                    const yaxis = `y${oscIndex + 2}`;
                    traces.push({
                        x: timestamps,
                        y: data.map(d => parseFloat(d.indicators.atr_14)),
                        type: 'scatter',
                        mode: 'lines',
                        name: 'ATR',
                        xaxis: 'x',
                        yaxis: yaxis,
                        line: {color: '#ff5722', width: 1.5}
                    });
                    oscIndex++;
                }
            }

            // Current price line ‚Äî dotted line from last candle close to right margin with price badge
            const lastPrice = data[0].close; // data[0] is newest (DESC order)
            const isJPYPair_ = symbol.toUpperCase().includes('JPY');
            const priceDecimals = isJPYPair_ ? 3 : 5;
            const currentPriceShape = {
                type: 'line',
                xref: 'paper',
                yref: 'y',
                x0: 0,
                x1: 1,
                y0: lastPrice,
                y1: lastPrice,
                line: { color: '#2962FF', width: 1, dash: 'dot' },
                layer: 'above'
            };
            const currentPriceAnnotation = {
                x: 1.0,
                xref: 'paper',
                y: lastPrice,
                yref: 'y',
                text: ` ${lastPrice.toFixed(priceDecimals)} `,
                showarrow: false,
                font: { size: 11, color: '#ffffff', family: 'Consolas, monospace' },
                bgcolor: '#2962FF',
                borderpad: 3,
                bordercolor: '#2962FF',
                xanchor: 'left'
            };

            // Build layout with dynamic subplots
            const layout = {
                paper_bgcolor: '#ffffff',
                plot_bgcolor: '#ffffff',
                font: {color: '#1f1f1f'},
                dragmode: 'pan',  // Enable pan mode (allows scroll wheel to zoom X-axis)
                hovermode: 'x unified',
                margin: {t: 30, r: 80, b: 40, l: 60},
                shapes: [currentPriceShape],
                annotations: [currentPriceAnnotation],
                legend: {
                    orientation: 'h',
                    y: 1.02,
                    font: {color: '#1f1f1f', size: 10}
                },
                xaxis: {
                    gridcolor: '#e5e7eb',
                    hoverformat: '%b %d, %Y, %H:%M UTC',
                    rangeslider: {visible: false},
                    rangebreaks: [
                        {
                            bounds: ['sat', 'mon'],  // Hide weekends completely
                            pattern: 'day of week'
                        }
                    ],
                    type: 'date',
                    domain: [0, 1],
                    // Show most recent candles based on candleLimit, but allow scrolling through all data
                    // Backend returns DESC (newest first), so timestamps[0] is most recent
                    range: data.length > candleLimit ? [
                        timestamps[candleLimit - 1].toISOString(),  // Nth newest (older date)
                        timestamps[0].toISOString()                  // Most recent (newer date)
                    ] : undefined
                },
                yaxis: (() => {
                    // Calculate Y-axis range from VISIBLE candles only (not indicators)
                    // This prevents SMA200/EMA etc from expanding the chart range
                    const visibleCount = Math.min(candleLimit, data.length);
                    const visibleData = data.slice(0, visibleCount);
                    const highs = visibleData.map(d => d.high).filter(h => h != null && !isNaN(h));
                    const lows = visibleData.map(d => d.low).filter(l => l != null && !isNaN(l));

                    if (highs.length === 0 || lows.length === 0) {
                        console.warn('‚ö†Ô∏è No valid OHLC data for Y-axis calculation');
                        return { gridcolor: '#e5e7eb', domain: mainHeight, fixedrange: false, tickformat: '.5f' };
                    }

                    const yMax = Math.max(...highs);
                    const yMin = Math.min(...lows);
                    const range = yMax - yMin;

                    // Sanity check: if range ratio is too large, data might be corrupted
                    if (yMax / yMin > 10) {
                        console.warn(`‚ö†Ô∏è Suspicious Y-axis range ratio: ${(yMax/yMin).toFixed(2)}x - possible data mixing`);
                        console.warn(`   Min: ${yMin}, Max: ${yMax}, Symbol: ${symbol}`);
                        // Fall back to autorange for safety
                        return { gridcolor: '#e5e7eb', domain: mainHeight, fixedrange: false, tickformat: '.5f' };
                    }

                    // Use 5% padding for comfortable viewing
                    const padding = Math.max(range * 0.05, yMax * 0.001);

                    console.log(`üìè Y-axis range: ${yMin.toFixed(5)} - ${yMax.toFixed(5)} (padding: ${padding.toFixed(5)})`);

                    return {
                        gridcolor: '#e5e7eb',
                        domain: mainHeight,
                        fixedrange: false,
                        tickformat: '.5f',
                        autorange: false,  // CRITICAL: Disable autorange to prevent indicator expansion
                        range: [yMin - padding, yMax + padding]
                    };
                })()
            };

            // Add oscillator axes
            oscIndex = 0;
            if (showVolume) {
                layout[`yaxis${oscIndex + 2}`] = {
                    gridcolor: '#e5e7eb',
                    domain: oscHeight[oscIndex],
                    fixedrange: true
                };
                oscIndex++;
            }
            if (showRSI) {
                layout[`yaxis${oscIndex + 2}`] = {
                    gridcolor: '#e5e7eb',
                    domain: oscHeight[oscIndex],
                    fixedrange: true,
                    range: [0, 100]
                };
                oscIndex++;
            }
            if (showMACD) {
                layout[`yaxis${oscIndex + 2}`] = {
                    gridcolor: '#e5e7eb',
                    domain: oscHeight[oscIndex],
                    fixedrange: true
                };
                oscIndex++;
            }
            if (showStochastic) {
                layout[`yaxis${oscIndex + 2}`] = {
                    gridcolor: '#e5e7eb',
                    domain: oscHeight[oscIndex],
                    fixedrange: true,
                    range: [0, 100]
                };
                oscIndex++;
            }
            if (showATR) {
                layout[`yaxis${oscIndex + 2}`] = {
                    gridcolor: '#e5e7eb',
                    domain: oscHeight[oscIndex],
                    fixedrange: true
                };
                oscIndex++;
            }

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false,
                scrollZoom: true,  // Enable scroll zoom (same as frontend-5173)
                modeBarButtonsToAdd: ['pan2d'],
                modeBarButtonsToRemove: ['lasso2d', 'select2d']
            };

            // Purge any existing chart to prevent data mixing when symbol changes
            Plotly.purge('chart');

            Plotly.newPlot('chart', traces, layout, config)
                .then(() => {
                    // Add dynamic Y-axis adjustment on zoom/pan
                    const chartDiv = document.getElementById('chart');

                    // Y-axis range is now set in initial layout configuration above
                    // No need for post-render adjustment on first load

                    chartDiv.on('plotly_relayout', (eventData) => {
                        console.log('üìä Relayout event:', eventData);

                        // Skip if this event was triggered by our own Y-axis update
                        // (prevents infinite loop)
                        if (eventData['yaxis.range'] || eventData['yaxis.autorange'] !== undefined) {
                            console.log('‚è≠Ô∏è Skipping - Y-axis update detected');
                            return;
                        }

                        // Only adjust if X-axis range changed (zoom or pan)
                        if (eventData['xaxis.range'] && Array.isArray(eventData['xaxis.range'])) {
                            console.log('üîç X-axis range changed, calculating Y-axis adjustment');

                            const xStart = new Date(eventData['xaxis.range'][0]).getTime();
                            const xEnd = new Date(eventData['xaxis.range'][1]).getTime();

                            // Get candlestick data from chart
                            const candleTrace = chartDiv.data.find(t => t.type === 'candlestick');
                            if (!candleTrace) {
                                console.log('‚ö†Ô∏è No candlestick trace found');
                                return;
                            }

                            // Filter candles within visible X-range
                            const visibleHighs = [];
                            const visibleLows = [];

                            for (let i = 0; i < candleTrace.x.length; i++) {
                                const ts = new Date(candleTrace.x[i]).getTime();
                                if (ts >= xStart && ts <= xEnd) {
                                    visibleHighs.push(candleTrace.high[i]);
                                    visibleLows.push(candleTrace.low[i]);
                                }
                            }

                            console.log(`üìà Visible candles: ${visibleHighs.length}`);

                            if (visibleHighs.length > 0) {
                                // Calculate Y-range from visible candles with 5% padding for better visibility
                                const yMax = Math.max(...visibleHighs);
                                const yMin = Math.min(...visibleLows);
                                const range = yMax - yMin;
                                // Use 5% padding, but ensure minimum padding for very tight ranges
                                const minPadding = yMax * 0.001; // 0.1% of price as minimum
                                const padding = Math.max(range * 0.05, minPadding); // 5% padding

                                console.log(`üìè Y-axis adjustment: ${yMin.toFixed(5)} - ${yMax.toFixed(5)} (padding: ${padding.toFixed(5)})`);

                                // Update Y-axis range
                                Plotly.relayout('chart', {
                                    'yaxis.range': [yMin - padding, yMax + padding],
                                    'yaxis.autorange': false
                                });
                            }
                        } else if (eventData['xaxis.autorange']) {
                            console.log('üîÑ Resetting to auto range');
                            // Reset to auto range when double-clicking
                            Plotly.relayout('chart', {
                                'yaxis.autorange': true
                            });
                        }
                    });
                });
        }

        // Signal name -> timeframe lookup (from paper_trading.yaml config)
        const SIGNAL_TIMEFRAMES = {
            'BB_RSI_Volume_short':'M30','BB_RSI_long':'M30','EMA_RSI_long':'H4','EMA_RSI_short':'D1',
            'MACD_Stoch_long':'H1','MACD_Stoch_short':'M30','MACD_cross_long':'M30',
            'RSI_BB_confluence_long':'H4','RSI_BB_confluence_short':'M30','RSI_oversold_long':'H1',
            'SMA20_200_BB_long':'H1','SMA20_200_RSI_Stoch_long':'H1','SMA20_200_RSI_Stoch_short':'M30',
            'SMA20_200_RSI_long':'H1','SMA20_200_Stoch_BB_short':'H2','SMA20_200_Stoch_long':'H12',
            'SMA20_200_Stoch_short':'H2','SMA20_50_BB_long':'H1','SMA20_50_BB_short':'H2',
            'SMA20_50_MACD_long':'H8','SMA20_50_RSI_MACD_long':'H6','SMA20_50_RSI_Stoch_BB_short':'H2',
            'SMA20_50_RSI_long':'H2','SMA20_50_Stoch_BB_short':'H2','SMA20_50_Stoch_long':'H8',
            'SMA50_200_BB_short':'H1','SMA50_200_MACD_long':'H2','SMA50_200_RSI_Stoch_BB_long':'H1',
            'SMA50_200_RSI_Stoch_BB_short':'H1','SMA50_200_RSI_Stoch_long':'H1','SMA50_200_RSI_Stoch_short':'H1',
            'SMA50_200_Stoch_BB_short':'H1','SMA50_200_Stoch_long':'H4','SMA50_200_Stoch_short':'H6',
            'SMA_20_50_cross_short':'H1','Stoch_RSI_long_15_25':'M30','Stoch_RSI_long_15_30':'H1',
            'Stoch_RSI_long_15_35':'H6','Stoch_RSI_long_20_25':'M30','Stoch_RSI_long_20_30':'H1',
            'Stoch_RSI_long_20_35':'H2','Stoch_RSI_long_25_25':'M30','Stoch_RSI_long_25_30':'H2',
            'Stoch_RSI_long_25_35':'H4','Stoch_RSI_short_15_25':'H1','Stoch_RSI_short_15_30':'H2',
            'Stoch_RSI_short_15_35':'H2','Stoch_RSI_short_20_25':'H1','Stoch_RSI_short_20_35':'H2',
            'Stoch_RSI_short_25_25':'H1','Stoch_RSI_short_25_35':'H2','Triple_Momentum_long':'H1',
        };
        function getSignalTimeframe(entryModel, item) {
            // Prefer signal_timeframe stored in DB (accurate per-position)
            if (item && item.signal_timeframe) return item.signal_timeframe;
            // Fallback to hardcoded lookup for old records
            if (!entryModel) return '-';
            const sig = entryModel.replace('Hybrid_V4 + ', '');
            return SIGNAL_TIMEFRAMES[sig] || '-';
        }

        // Global trades data for filtering
        let _allTradesData = [];
        let _openCount = 0;
        let _closedCount = 0;

        async function loadTrades() {
            const status = document.getElementById('tradesStatus');
            const tbody = document.getElementById('tradesBody');

            status.className = 'status loading';
            status.textContent = 'üü° Loading...';

            try {
                const [positionsRes, tradesRes] = await Promise.all([
                    fetch(`${API_BASE}/paper-trading/positions`),
                    fetch(`${API_BASE}/paper-trading/trades?limit=1000`),
                    fetchMT5Positions(),
                    fetchMT5HistoryDeals(),
                    fetchMT5Account()
                ]);

                if (!positionsRes.ok || !tradesRes.ok) throw new Error('API request failed');

                const positionsResult = await positionsRes.json();
                const tradesResult = await tradesRes.json();

                const openPositions = (positionsResult.data || []).map(p => {
                    const mt5 = matchMT5Position(p.symbol, p.direction, p.ticket);
                    const dir = (p.direction || '').toLowerCase();
                    // When MT5 data available, use broker values (actual fill prices)
                    if (mt5) {
                        const isJpy = (p.symbol || '').toUpperCase().includes('JPY');
                        const pipMul = isJpy ? 100 : 10000;
                        const isLong = dir === 'long';
                        const mt5Pips = isLong
                            ? (mt5.price_current - mt5.price_open) * pipMul
                            : (mt5.price_open - mt5.price_current) * pipMul;
                        return {
                            ...p,
                            status: 'OPEN',
                            direction: dir,
                            entry_price: mt5.price_open,
                            current_price: mt5.price_current,
                            pnl_pips: Math.round(mt5Pips * 10) / 10,
                            lots: mt5.volume,
                            size: mt5.volume,
                            mt5_profit: mt5.profit,
                            mt5_volume: mt5.volume
                        };
                    }
                    return {
                        ...p,
                        status: 'OPEN',
                        direction: dir,
                        mt5_profit: null,
                        mt5_volume: null
                    };
                });
                const closedTrades = (tradesResult.data || []).map(t => {
                    const mt5Deal = matchMT5HistoryDeal(t);
                    return {
                        ...t,
                        status: 'CLOSED',
                        direction: (t.direction || '').toLowerCase(),
                        mt5_profit: mt5Deal ? mt5Deal.profit : null,
                        mt5_volume: mt5Deal ? mt5Deal.volume : null,
                        mt5_swap: mt5Deal ? mt5Deal.swap : null
                    };
                });

                _allTradesData = [...openPositions, ...closedTrades]
                    .sort((a, b) => new Date(b.opened_at) - new Date(a.opened_at));
                _openCount = openPositions.length;
                _closedCount = closedTrades.length;

                // Populate filter dropdowns from actual data
                populateFilterOptions(_allTradesData);

                // Render with current filters
                applyTradeFilters();

                status.className = 'status connected';
                const formattedTime = formatDateTime(new Date());
                status.textContent = `üü¢ ${_openCount} open, ${_closedCount} closed | Updated: ${formattedTime}`;
            } catch (error) {
                status.className = 'status error';
                status.textContent = 'üî¥ Error: ' + error.message;
                tbody.innerHTML = `<tr><td colspan="12" style="text-align: center; padding: 40px; color: #ef4444;">Error loading trades: ${error.message}</td></tr>`;
            }
        }

        function populateFilterOptions(trades) {
            const symbolSelect = document.getElementById('filterSymbol');
            const modelSelect = document.getElementById('filterModel');

            // Preserve current selections
            const curSymbol = symbolSelect.value;
            const curModel = modelSelect.value;

            // Get unique symbols and models
            const symbols = [...new Set(trades.map(t => t.symbol).filter(Boolean))].sort();
            const models = [...new Set(trades.map(t => t.entry_model).filter(Boolean))].sort();

            symbolSelect.innerHTML = '<option value="">All</option>' + symbols.map(s => `<option value="${s}"${s === curSymbol ? ' selected' : ''}>${s}</option>`).join('');
            modelSelect.innerHTML = '<option value="">All</option>' + models.map(m => `<option value="${m}"${m === curModel ? ' selected' : ''}>${m}</option>`).join('');
        }

        function applyTradeFilters() {
            const filterDate = document.getElementById('filterDate').value;
            const filterSymbol = document.getElementById('filterSymbol').value;
            const filterType = document.getElementById('filterType').value;
            const filterModel = document.getElementById('filterModel').value;
            const filterStatus = document.getElementById('filterStatus').value;

            let filtered = _allTradesData;

            if (filterDate) {
                filtered = filtered.filter(t => {
                    const dateStr = (t.status === 'CLOSED' && t.closed_at) ? t.closed_at : t.opened_at;
                    const d = new Date(dateStr);
                    const tradeDate = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
                    return tradeDate === filterDate;
                });
            }
            if (filterSymbol) {
                filtered = filtered.filter(t => t.symbol === filterSymbol);
            }
            if (filterType) {
                filtered = filtered.filter(t => t.direction === filterType);
            }
            if (filterModel) {
                filtered = filtered.filter(t => t.entry_model === filterModel);
            }
            if (filterStatus) {
                filtered = filtered.filter(t => t.status === filterStatus);
            }

            renderTradesTable(filtered);
            updateAnalytics(filtered);

            // Show filter count
            const countEl = document.getElementById('filterCount');
            const hasFilter = filterDate || filterSymbol || filterType || filterModel || filterStatus;
            countEl.textContent = hasFilter ? `Showing ${filtered.length} of ${_allTradesData.length} trades` : '';
        }

        function clearTradeFilters() {
            document.getElementById('filterDate').value = '';
            document.getElementById('filterSymbol').value = '';
            document.getElementById('filterType').value = '';
            document.getElementById('filterModel').value = '';
            document.getElementById('filterStatus').value = '';
            applyTradeFilters();
        }

        function renderTradesTable(trades) {
            const tbody = document.getElementById('tradesBody');

            if (trades.length === 0) {
                tbody.innerHTML = '<tr><td colspan="12" style="text-align: center; padding: 40px; color: #6b7280;">No trades match filters</td></tr>';
                return;
            }

            tbody.innerHTML = trades.map(trade => {
                const isActive = trade.status === 'OPEN';
                const pnl = trade.pnl_pips || 0;
                const pnlClass = pnl >= 0 ? 'trade-buy' : 'trade-sell';
                const rowClass = isActive ? 'trade-active' : '';
                const modelName = trade.entry_model || '-';
                const sizeVal = trade.size != null ? parseFloat(trade.size) : null;
                const lots = sizeVal != null ? sizeVal.toFixed(2) : (trade.mt5_volume != null ? trade.mt5_volume.toFixed(2) : (trade.lots != null ? trade.lots.toFixed(2) : '-'));

                // MT5 profit in account currency (open positions from live feed, closed from history deals)
                const mt5Cur = _mt5Currency || 'USD';
                let mt5PnlStr = '-';
                if (trade.mt5_profit != null) {
                    const profitVal = trade.mt5_profit;
                    const swapVal = trade.mt5_swap || 0;
                    const totalProfit = profitVal + swapVal;
                    const profitColor = totalProfit >= 0 ? '#10b981' : '#ef4444';
                    const swapNote = swapVal !== 0 ? ` <span style="font-size:10px;color:#6b7280">(swap ${swapVal >= 0 ? '+' : ''}${swapVal.toFixed(1)})</span>` : '';
                    mt5PnlStr = `<span style="color: ${profitColor}; font-weight: 500;">${totalProfit >= 0 ? '+' : ''}${totalProfit.toFixed(2)} ${mt5Cur}</span>${swapNote}`;
                }

                return `
                    <tr class="${rowClass}">
                        <td>${trade.id}</td>
                        <td>${trade.symbol}</td>
                        <td class="${trade.direction === 'long' ? 'dir-long' : 'dir-short'}">
                            ${trade.direction.toUpperCase()}
                        </td>
                        <td>${lots}</td>
                        <td>${trade.entry_price.toFixed(5)}</td>
                        <td>${trade.current_price ? trade.current_price.toFixed(5) : (trade.exit_price ? trade.exit_price.toFixed(5) : '-')}</td>
                        <td><span class="${pnlClass}">${pnl.toFixed(1)}</span></td>
                        <td>${mt5PnlStr}</td>
                        <td style="font-size: 11px; color: #6b7280;">${modelName}</td>
                        <td style="font-size: 11px; font-weight: 600; color: #4b5563;">${getSignalTimeframe(trade.entry_model, trade)}</td>
                        <td>${formatDateTime(trade.opened_at)}</td>
                        <td>${trade.status}</td>
                    </tr>
                `;
            }).join('');
        }

        function updateAnalytics(trades) {
            const totalPnl = trades.reduce((sum, t) => sum + (t.pnl_pips || 0), 0);
            // Win rate: use MT5 profit (real money) when available, fall back to pips
            const winningTrades = trades.filter(t => {
                const mt5Profit = t.mt5_profit != null ? t.mt5_profit + (t.mt5_swap || 0) : null;
                return mt5Profit != null ? mt5Profit > 0 : (t.pnl_pips || 0) > 0;
            }).length;
            const winRate = trades.length > 0 ? (winningTrades / trades.length) * 100 : 0;
            const bestTrade = trades.length > 0 ? Math.max(...trades.map(t => t.pnl_pips || 0)) : 0;

            // Calculate total MT5 profit in account currency (open + closed)
            const mt5Cur = _mt5Currency || 'USD';
            const mt5Trades = trades.filter(t => t.mt5_profit != null);
            const totalMt5Profit = mt5Trades.reduce((sum, t) => sum + t.mt5_profit + (t.mt5_swap || 0), 0);
            const mt5Suffix = mt5Trades.length > 0 ? ` (${totalMt5Profit >= 0 ? '+' : ''}${totalMt5Profit.toFixed(0)} ${mt5Cur})` : '';

            document.getElementById('analytics-total-pnl').innerHTML = `${totalPnl >= 0 ? '+' : ''}${totalPnl.toFixed(1)} pips<span style="font-size: 14px; color: #6b7280;">${mt5Suffix}</span>`;
            document.getElementById('analytics-total-pnl').style.color = totalPnl >= 0 ? '#10b981' : '#ef4444';
            document.getElementById('analytics-win-rate').textContent = `${winRate.toFixed(1)}%`;
            document.getElementById('analytics-win-rate').style.color = winRate >= 50 ? '#10b981' : '#ef4444';
            const openCount = trades.filter(t => t.status === 'OPEN').length;
            document.getElementById('analytics-total-trades').innerHTML = openCount > 0
                ? `${trades.length} <span style="font-size: 13px; color: #6b7280; font-weight: 400;">(${openCount} open)</span>`
                : `${trades.length}`;
        }

        // ============================================================================
        // Decision Log Functions
        // ============================================================================

        let _decisionsData = [];
        let _expandedDecisions = new Set();
        let _positionHistoryCache = {}; // positionId -> [decisions]

        async function loadDecisions() {
            const status = document.getElementById('decisionsStatus');
            const tbody = document.getElementById('decisionsBody');
            status.className = 'status loading';
            status.textContent = 'Loading...';

            const logType = document.getElementById('decFilterType').value;
            const symbol = document.getElementById('decFilterSymbol').value;
            const direction = document.getElementById('decFilterDir').value;
            const limit = document.getElementById('decFilterLimit').value;

            const params = new URLSearchParams();
            if (logType) params.set('log_type', logType);
            if (symbol) params.set('symbol', symbol);
            if (direction) params.set('direction', direction);
            if (limit) params.set('limit', limit);

            try {
                const res = await fetch(`${API_BASE}/paper-trading/decisions?${params}`);
                if (!res.ok) throw new Error('API request failed');
                const result = await res.json();
                _decisionsData = result.data || [];

                renderDecisionsTable(_decisionsData);
                updateDecisionSummary(_decisionsData);

                status.className = 'status connected';
                status.textContent = `${_decisionsData.length} entries | ${formatDateTime(new Date())}`;
                document.getElementById('decFilterCount').textContent = `${_decisionsData.length} entries loaded`;
            } catch (error) {
                status.className = 'status error';
                status.textContent = 'Error: ' + error.message;
                tbody.innerHTML = `<tr><td colspan="6" style="text-align: center; padding: 40px; color: #ef4444;">Error: ${error.message}</td></tr>`;
            }
        }

        function updateDecisionSummary(decisions) {
            document.getElementById('dec-total').textContent = decisions.length;
            const accepted = decisions.filter(d => d.log_type === 'signal_generated' || d.log_type === 'position_opened').length;
            const rejected = decisions.filter(d => d.log_type === 'signal_rejected' || d.log_type === 'risk_violation').length;
            document.getElementById('dec-accepted').textContent = accepted;
            document.getElementById('dec-rejected').textContent = rejected;

            const rlExits = decisions.filter(d => d.log_type === 'rl_exit_decision');
            const closeCount = rlExits.filter(d => d.context_data && d.context_data.action === 'CLOSE').length;
            const holdCount = rlExits.filter(d => d.context_data && d.context_data.action === 'HOLD').length;
            document.getElementById('dec-rl-exits').textContent = rlExits.length > 0 ? `${closeCount}C / ${holdCount}H` : '-';
        }

        function renderDecisionsTable(decisions) {
            const tbody = document.getElementById('decisionsBody');
            if (decisions.length === 0) {
                tbody.innerHTML = '<tr><td colspan="9" style="text-align: center; padding: 40px; color: #6b7280;">No decisions match filters</td></tr>';
                return;
            }

            tbody.innerHTML = decisions.map((d, idx) => {
                const isExpanded = _expandedDecisions.has(d.id);
                const typeName = d.log_type.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
                const dirClass = d.direction === 'LONG' ? 'dir-long' : d.direction === 'SHORT' ? 'dir-short' : '';

                // Build per-column values
                let actionCell = '-';
                let closePctCell = '-';
                let votesCell = '-';
                let pnlCell = '-';
                let detailStr = '';

                if (d.log_type === 'rl_exit_decision' && d.context_data) {
                    const ctx = d.context_data;
                    const action = ctx.action || '?';
                    const actionColor = action === 'CLOSE' ? '#ef4444' : '#10b981';
                    actionCell = `<span style="color:${actionColor};font-weight:600">${action}</span>`;

                    const votes = ctx.ensemble_votes;
                    if (votes) {
                        const closeV = votes.close_votes || 0;
                        const holdV = votes.hold_votes || 0;
                        const closeProb = votes.mean_close_prob != null ? (votes.mean_close_prob * 100).toFixed(1) : null;
                        const overrideIcon = votes.threshold_override ? ' <span style="color:#f59e0b" title="CLOSE overridden to HOLD by 55% threshold">‚äò</span>' : '';
                        closePctCell = closeProb != null ? `${closeProb}%${overrideIcon}` : '-';
                        votesCell = `${closeV}C / ${holdV}H`;
                    }

                    if (ctx.unrealized_pnl_pips != null) {
                        const pnlVal = parseFloat(ctx.unrealized_pnl_pips);
                        const pnlColor = pnlVal >= 0 ? '#10b981' : '#ef4444';
                        pnlCell = `<span style="color:${pnlColor}">${pnlVal.toFixed(1)}</span>`;
                    }

                    const bars = ctx.position_bars != null ? `bars=${ctx.position_bars}` : '';
                    detailStr = bars;
                } else if (d.log_type === 'signal_rejected' && d.rejection_reason) {
                    detailStr = `<span style="color: #92400e;">${d.rejection_reason}</span>`;
                } else if (d.log_type === 'position_closed' && d.context_data) {
                    const ctx = d.context_data;
                    const pnl = ctx.pnl_pips != null ? parseFloat(ctx.pnl_pips).toFixed(1) : '?';
                    const reason = ctx.exit_reason || '';
                    const pnlColor = parseFloat(pnl) >= 0 ? '#10b981' : '#ef4444';
                    pnlCell = `<span style="color:${pnlColor}">${pnl}</span>`;
                    detailStr = reason;
                } else if (d.log_type === 'risk_violation' && d.rejection_reason) {
                    detailStr = `<span style="color: #9d174d;">${d.rejection_reason}</span>`;
                } else if (d.log_type === 'signal_generated' || d.log_type === 'position_opened') {
                    if (d.signal_confidence != null) {
                        closePctCell = `${(d.signal_confidence * 100).toFixed(1)}%`;
                    }
                }

                let contextRow = '';
                if (isExpanded && d.context_data) {
                    let historyBlock = '';
                    if (d.log_type === 'rl_exit_decision' && d.context_data.position_id) {
                        const posId = String(d.context_data.position_id);
                        const history = _positionHistoryCache[posId] || [];
                        if (history.length > 0) {
                            const historyEntries = history.map((h, i) => {
                                const ctx = h.context_data;
                                const ts = new Date(h.timestamp).toISOString().replace('T', ' ').substring(0, 19);
                                const actionColor = ctx.action === 'CLOSE' ? '#ef4444' : '#10b981';
                                const pnl = ctx.unrealized_pnl_pips != null ? parseFloat(ctx.unrealized_pnl_pips).toFixed(1) : '?';
                                const conf = ctx.confidence != null ? (parseFloat(ctx.confidence) * 100).toFixed(1) : '?';
                                const votes = ctx.ensemble_votes || {};
                                const isCurrent = h.id === d.id;
                                const closeProb = votes.mean_close_prob != null ? (votes.mean_close_prob * 100).toFixed(1) + '%' : conf + '%';
                                const overrideTag = votes.threshold_override ? ' ‚äò' : '';
                                return `<span style="color:${isCurrent ? '#fff' : '#6b7280'};background:${isCurrent ? '#1e40af' : 'transparent'};padding:2px 6px;border-radius:3px;font-weight:${isCurrent ? '700' : '400'}">#${i + 1} ${ts} | <span style="color:${isCurrent ? '#93c5fd' : actionColor};font-weight:600">${ctx.action}</span> ${closeProb} (${votes.close_votes || '?'}C/${votes.hold_votes || '?'}H)${overrideTag} | ${pnl} pips | bars=${ctx.position_bars || '?'}</span>`;
                            });
                            historyBlock = `\n\n--- Position ${posId} Decision History (${history.length} evaluations) ---\n${historyEntries.join('\n')}`;
                        }
                    }
                    contextRow = `<tr><td colspan="9"><div class="decision-context">${JSON.stringify(d.context_data, null, 2)}${historyBlock}</div></td></tr>`;
                }

                return `
                    <tr onclick="toggleDecisionDetail(${d.id})" style="cursor:pointer;">
                        <td style="font-size: 12px; white-space: nowrap;">${formatDateTime(d.timestamp)}</td>
                        <td><span class="decision-badge ${d.log_type}">${typeName}</span></td>
                        <td>${d.symbol || '-'}</td>
                        <td class="${dirClass}">${d.direction || '-'}</td>
                        <td>${actionCell}</td>
                        <td>${closePctCell}</td>
                        <td style="white-space:nowrap">${votesCell}</td>
                        <td>${pnlCell}</td>
                        <td>${detailStr || '-'}</td>
                    </tr>
                    ${contextRow}
                `;
            }).join('');
        }

        async function toggleDecisionDetail(id) {
            if (_expandedDecisions.has(id)) {
                _expandedDecisions.delete(id);
                renderDecisionsTable(_decisionsData);
                return;
            }
            _expandedDecisions.add(id);
            // If RL exit decision, fetch full position history from backend
            const d = _decisionsData.find(x => x.id === id);
            if (d && d.log_type === 'rl_exit_decision' && d.context_data && d.context_data.position_id) {
                const posId = String(d.context_data.position_id);
                if (!_positionHistoryCache[posId]) {
                    try {
                        const resp = await fetch(`/api/paper-trading/decisions?position_id=${posId}&log_type=rl_exit_decision&limit=500`);
                        const json = await resp.json();
                        _positionHistoryCache[posId] = (json.data || []).sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                    } catch (e) {
                        console.error('Failed to fetch position history:', e);
                    }
                }
            }
            renderDecisionsTable(_decisionsData);
        }

        // ============================================================================
        // MT5 P&L Enrichment for Paper Trading (currency from API)
        // ============================================================================

        let _mt5Positions = null;

        let _mt5HistoryDeals = []; // MT5 closed deal history

        async function fetchMT5Positions() {
            // TFG: No MT5 broker connection
            return null;
        }

        async function fetchMT5HistoryDeals() {
            // TFG: No MT5 broker connection
        }

        function matchMT5Position(paperSymbol, paperDirection, paperTicket) {
            if (!_mt5Positions || !paperSymbol) return null;
            // Prefer exact ticket match (handles multiple positions in same symbol+direction)
            if (paperTicket) {
                const byTicket = _mt5Positions.find(p => p.ticket === paperTicket);
                if (byTicket) return byTicket;
            }
            // Fallback: symbol + direction (for positions without ticket)
            const normalized = paperSymbol.toUpperCase();
            const isLong = (paperDirection || '').toLowerCase() === 'long';
            return _mt5Positions.find(p => {
                const mt5Sym = (p.symbol || '').replace('.pro', '').toUpperCase();
                return mt5Sym === normalized && (p.type === 0) === isLong;
            });
        }

        function matchMT5HistoryDeal(paperTrade) {
            if (!_mt5HistoryDeals.length || !paperTrade.symbol) return null;
            const sym = paperTrade.symbol.toUpperCase();
            const dir = (paperTrade.direction || '').toLowerCase();
            const entryTime = new Date(paperTrade.entry_time || paperTrade.opened_at).getTime() / 1000;

            // Find MT5 deal matching symbol + direction + entry within 120 seconds
            let bestMatch = null;
            let bestDiff = Infinity;
            for (const deal of _mt5HistoryDeals) {
                if (deal.symbol !== sym || deal.direction !== dir) continue;
                if (!deal.is_closed) continue;
                const diff = Math.abs(deal.entry_time_utc - entryTime);
                if (diff < 120 && diff < bestDiff) {
                    bestDiff = diff;
                    bestMatch = deal;
                }
            }
            return bestMatch;
        }

        // Fetch model info for a specific symbol (for sidebar)
        async function fetchSymbolModelInfo(symbol) {
            try {
                const backendSymbol = symbol.replace('/', '').toUpperCase();
                const response = await fetch(`${API_BASE}/paper-trading/models/${backendSymbol}`);
                if (!response.ok) return null;
                const result = await response.json();
                return normalizeDirections(result.data);
            } catch (error) {
                console.warn('Model info not available:', error);
                return null;
            }
        }

        // Fetch model performance validation metrics
        async function fetchModelPerformance() {
            try {
                const response = await fetch(`${API_BASE}/paper-trading/model-performance`);
                if (!response.ok) return null;
                const result = await response.json();

                // Create a map keyed by symbol_direction for easy lookup
                const performanceMap = {};
                if (result.data && Array.isArray(result.data)) {
                    result.data.forEach(perf => {
                        perf.direction = (perf.direction || '').toLowerCase();
                        const key = `${perf.symbol}_${perf.direction}`;
                        performanceMap[key] = perf;
                    });
                }
                return performanceMap;
            } catch (error) {
                console.warn('Model performance not available:', error);
                return null;
            }
        }

        // Fetch LIVE trading performance from paper_trades table
        async function fetchLiveTradingPerformance() {
            try {
                const response = await fetch(`${API_BASE}/paper-trading/live-performance`);
                if (!response.ok) return null;
                const result = await response.json();

                // Create a map keyed by symbol_direction for easy lookup
                const livePerformanceMap = {};
                if (result.data && Array.isArray(result.data)) {
                    result.data.forEach(perf => {
                        perf.direction = (perf.direction || '').toLowerCase();
                        const key = `${perf.symbol}_${perf.direction}`;
                        livePerformanceMap[key] = perf;
                    });
                }
                return livePerformanceMap;
            } catch (error) {
                console.warn('Live trading performance not available:', error);
                return null;
            }
        }

        // Update model info card in sidebar
        async function updateModelInfoCard() {
            const symbol = document.getElementById('symbol').value;
            const container = document.getElementById('modelInfoContent');

            const [modelInfo, performanceMap, openPositions, livePerformanceMap] = await Promise.all([
                fetchSymbolModelInfo(symbol),
                fetchModelPerformance(),
                fetchOpenPositions(symbol),
                fetchLiveTradingPerformance()
            ]);

            if (!modelInfo) {
                container.innerHTML = `<div style="color: #6b7280; text-align: center; padding: 12px;">No model info available</div>`;
                return;
            }

            // Check for active positions - show actual entry model if position is open
            const activePosition = openPositions.find(pos => pos.symbol === symbol.replace('/', ''));

            // Paper trading signals - prefer active position's entry model over config
            let signalInfo;
            let activeTimeframe = modelInfo.timeframe;

            if (activePosition && activePosition.entry_model) {
                // Extract timeframe from entry_model if present (e.g., "Hybrid V4 + M30_SMA20..." -> "M30")
                const tfMatch = activePosition.entry_model.match(/([MHDR]\d+)_/);
                if (tfMatch) {
                    activeTimeframe = tfMatch[1];
                }
                const directionClass = activePosition.direction === 'long' ? 'dir-long' : 'dir-short';
                const directionIcon = activePosition.direction === 'long' ? '‚ñ≤' : '‚ñº';
                signalInfo = `<div style="margin-bottom: 8px; padding: 8px; background: #fef3c7; border-radius: 4px; border: 1px solid #fcd34d;">
                    <div style="color: #92400e; font-size: 10px; font-weight: 600; margin-bottom: 4px;">üìä Active Position Signal:</div>
                    <div style="padding-left: 4px;">
                        <span class="${directionClass}" style="font-weight: 600;">${directionIcon} ${activePosition.direction.toUpperCase()}:</span>
                        <span style="font-weight: 500; margin-left: 4px; font-size: 11px;">${activePosition.entry_model.replace(/_/g, ' ')}</span>
                    </div>
                </div>`;
            } else {
                // Fallback to configured signals from config
                const activeSignals = modelInfo.activeSignals || [];
                signalInfo = activeSignals.length > 0
                    ? `<div style="margin-bottom: 8px;">
                        <div style="color: #6b7280; margin-bottom: 4px;">Paper Trading${activeSignals.length > 1 ? ' (Bidirectional)' : ''}:</div>
                        ${activeSignals.map(sig => `
                            <div style="margin-bottom: 4px; padding-left: 8px;">
                                <span class="${sig.direction === 'long' ? 'dir-long' : 'dir-short'}" style="font-weight: 600;">${sig.direction === 'long' ? '‚ñ≤' : '‚ñº'} ${sig.direction.toUpperCase()}:</span>
                                <span style="font-weight: 500; margin-left: 4px;">${sig.signal.replace(/_/g, ' ')}</span>
                            </div>
                        `).join('')}
                       </div>`
                    : '<div style="margin-bottom: 8px; color: #6b7280;">No signal configured</div>';
            }

            const rlStatus = modelInfo.rlModel.available
                ? `<span style="color: #10b981;">‚úì Active</span> (${modelInfo.rlModel.foldCount} folds)`
                : '<span style="color: #f59e0b;">‚ö† Not available</span>';

            // Direction-specific models (Issue #512) with REAL profitability metrics
            const dirModels = modelInfo.directionModels || {};
            const backendSymbol = symbol.replace('/', '').toUpperCase();

            const formatProfitabilityMetrics = (direction, dm, performanceMap) => {
                if (!dm) return `<span style="color: #d1d5db;">No model</span>`;
                if (!dm.available) return `<span style="color: #f59e0b;">‚ö† Model not found</span>`;

                // Check if we have performance data
                const perfKey = `${backendSymbol}_${direction}`;
                const perf = performanceMap?.[perfKey];

                if (!perf) {
                    // Fallback to old validation data with warning
                    return `<span style="color: #f59e0b;" title="${dm.modelPath}">‚ö† NOT VALIDATED - Fold ${dm.fold} (${Math.round(dm.validationWinRate)}% on ${dm.validationTrades} trades)</span>`;
                }

                // Determine status icon and color
                let statusIcon, statusColor, statusBg;
                if (perf.is_profitable && perf.profit_factor > 1.2) {
                    statusIcon = '‚úÖ';
                    statusColor = '#166534';
                    statusBg = '#dcfce7';
                } else if (perf.is_profitable && perf.profit_factor <= 1.2) {
                    statusIcon = '‚ö†Ô∏è';
                    statusColor = '#92400e';
                    statusBg = '#fef3c7';
                } else {
                    statusIcon = '‚ùå';
                    statusColor = '#991b1b';
                    statusBg = '#fee2e2';
                }

                // Build detailed tooltip
                const spreadCost = perf.total_pnl - perf.total_pnl_after_costs;
                const tooltip = `Total Trades: ${perf.total_trades}
Win Rate: ${perf.win_rate.toFixed(1)}%
Avg Win: +${perf.avg_win.toFixed(1)} pips
Avg Loss: ${perf.avg_loss.toFixed(1)} pips
R:R: ${perf.risk_reward_ratio.toFixed(2)}:1
Expectancy: ${perf.expectancy.toFixed(2)} pips/trade
Profit Factor: ${perf.profit_factor.toFixed(2)}
Total PnL: ${perf.total_pnl_after_costs.toFixed(1)} pips (after ${spreadCost.toFixed(1)} pips spread)
Max DD: ${perf.max_drawdown_pips.toFixed(1)} pips (${perf.max_drawdown_percent.toFixed(1)}%)
Sharpe: ${perf.sharpe_ratio.toFixed(2)}
Status: ${perf.status.toUpperCase()} ${statusIcon}`;

                // Compact display
                const directionLabel = direction === 'long' ? '‚ñ≤' : '‚ñº';
                const displayText = `${perf.win_rate.toFixed(1)}% WR | ${perf.expectancy >= 0 ? '+' : ''}${perf.expectancy.toFixed(1)} pips/trade | PF: ${perf.profit_factor.toFixed(2)}`;

                return `<div style="padding: 4px 6px; background: ${statusBg}; border-radius: 4px; font-size: 10px; margin-bottom: 4px;" title="${tooltip}">
                    <div style="color: ${statusColor}; font-weight: 600;">${directionLabel} ${direction.toUpperCase()}: ${displayText} ${statusIcon}</div>
                    <div style="color: #6b7280; font-size: 9px; margin-top: 2px;">
                        ${perf.total_trades} trades | Total: ${perf.total_pnl_after_costs >= 0 ? '+' : ''}${perf.total_pnl_after_costs.toFixed(1)} pips
                    </div>
                </div>`;
            };

            const dirModelHtml = (dirModels.long || dirModels.short)
                ? `<div style="margin-top: 8px; padding: 8px; background: #eff6ff; border-radius: 4px; border: 1px solid #bfdbfe;">
                    <div style="font-size: 11px; color: #1e40af; font-weight: 600; margin-bottom: 6px;">üí∞ Real Profitability (Validation)</div>
                    ${dirModels.long ? formatProfitabilityMetrics('long', dirModels.long, performanceMap) : ''}
                    ${dirModels.short ? formatProfitabilityMetrics('short', dirModels.short, performanceMap) : ''}
                    ${!performanceMap ? '<div style="font-size: 9px; color: #6b7280; margin-top: 4px;">‚ö†Ô∏è Performance data unavailable</div>' : ''}
                   </div>`
                : '';

            // Format LIVE trading performance for sidebar card
            const formatLivePerfSidebar = (direction) => {
                const perfKey = `${backendSymbol}_${direction}`;
                const perf = livePerformanceMap?.[perfKey];
                if (!perf || perf.total_trades === 0) {
                    return `<div style="padding: 4px 6px; background: #f3f4f6; border-radius: 4px; font-size: 10px; margin-bottom: 4px;">
                        <div style="color: #6b7280;">${direction === 'long' ? '‚ñ≤' : '‚ñº'} ${direction.toUpperCase()}: No trades yet</div>
                    </div>`;
                }

                const pnlColor = perf.total_pnl_pips >= 0 ? '#166534' : '#991b1b';
                const pnlBg = perf.total_pnl_pips >= 0 ? '#dcfce7' : '#fee2e2';
                const wrColor = perf.win_rate >= 50 ? '#166534' : (perf.win_rate >= 40 ? '#92400e' : '#991b1b');
                const tooltip = `Trades: ${perf.total_trades} (${perf.winning_trades}W/${perf.losing_trades}L)
Win Rate: ${perf.win_rate}%
Total PnL: ${perf.total_pnl_pips >= 0 ? '+' : ''}${perf.total_pnl_pips} pips
Avg PnL: ${perf.avg_pnl_pips >= 0 ? '+' : ''}${perf.avg_pnl_pips} pips/trade
PF: ${perf.profit_factor === Infinity ? '‚àû' : perf.profit_factor.toFixed(2)}
First: ${perf.first_trade ? new Date(perf.first_trade).toLocaleDateString() : '-'}
Last: ${perf.last_trade ? new Date(perf.last_trade).toLocaleDateString() : '-'}`;

                return `<div style="padding: 4px 6px; background: ${pnlBg}; border-radius: 4px; font-size: 10px; margin-bottom: 4px;" title="${tooltip}">
                    <div style="color: ${pnlColor}; font-weight: 600;">${direction === 'long' ? '‚ñ≤' : '‚ñº'} ${direction.toUpperCase()}: ${perf.win_rate}% WR | ${perf.total_pnl_pips >= 0 ? '+' : ''}${perf.total_pnl_pips} pips</div>
                    <div style="color: #6b7280; font-size: 9px; margin-top: 2px;">
                        ${perf.total_trades} trades | Avg: ${perf.avg_pnl_pips >= 0 ? '+' : ''}${perf.avg_pnl_pips} pips/trade
                    </div>
                </div>`;
            };

            const livePerformanceHtml = livePerformanceMap
                ? `<div style="margin-top: 8px; padding: 8px; background: #f0fdf4; border-radius: 4px; border: 1px solid #bbf7d0;">
                    <div style="font-size: 11px; color: #166534; font-weight: 600; margin-bottom: 6px;">üìà Live Trading Performance</div>
                    ${formatLivePerfSidebar('long')}
                    ${formatLivePerfSidebar('short')}
                   </div>`
                : '';

            // All active signal validations (can have multiple LONG and/or SHORT)
            const activeValidations = modelInfo.activeSignalValidations || [];
            const longValidations = activeValidations.filter(v => v.direction === 'long');
            const shortValidations = activeValidations.filter(v => v.direction === 'short');
            const allSignalsHtml = activeValidations.length > 0
                ? `<div style="margin-top: 8px; padding: 8px; background: #f0fdf4; border-radius: 4px; border: 1px solid #bbf7d0;">
                    <div style="font-size: 11px; color: #166534; font-weight: 600; margin-bottom: 6px;">üìä Active Validated Strategies</div>
                    ${longValidations.length > 0 ? longValidations.map(sig => `<div style="display: flex; justify-content: space-between; margin-bottom: 4px; align-items: center;">
                        <span class="dir-long" style="font-weight: 500;">‚ñ≤ LONG:</span>
                        <span style="font-size: 11px; flex: 1; margin: 0 4px;">${sig.signal.replace(/_/g, ' ')}</span>
                        <span style="font-weight: 600;">${sig.profitFactor ? `<span style="color: ${sig.profitFactor > 1.5 ? '#059669' : sig.profitFactor > 1.2 ? '#d97706' : '#ef4444'};">PF:${sig.profitFactor.toFixed(2)}</span>` : `<span style="color: #6b7280;">-</span>`}${sig.testTrades ? ` <span style="color: #6b7280; font-size: 10px;">(${sig.testTrades})</span>` : ''}</span>
                    </div>`).join('') : '<div style="color: #6b7280; font-size: 11px;">‚ñ≤ LONG: No active signal</div>'}
                    ${shortValidations.length > 0 ? shortValidations.map(sig => `<div style="display: flex; justify-content: space-between; margin-bottom: 4px; align-items: center;">
                        <span class="dir-short" style="font-weight: 500;">‚ñº SHORT:</span>
                        <span style="font-size: 11px; flex: 1; margin: 0 4px;">${sig.signal.replace(/_/g, ' ')}</span>
                        <span style="font-weight: 600;">${sig.profitFactor ? `<span style="color: ${sig.profitFactor > 1.5 ? '#059669' : sig.profitFactor > 1.2 ? '#d97706' : '#ef4444'};">PF:${sig.profitFactor.toFixed(2)}</span>` : `<span style="color: #6b7280;">-</span>`}${sig.testTrades ? ` <span style="color: #6b7280; font-size: 10px;">(${sig.testTrades})</span>` : ''}</span>
                    </div>`).join('') : '<div style="color: #6b7280; font-size: 11px;">‚ñº SHORT: No active signal</div>'}
                   </div>`
                : '';

            // Show validation metrics for ALL active signals
            const validationInfo = activeValidations.length > 0
                ? `<div style="margin-top: 8px; padding: 8px; background: #f3f4f6; border-radius: 4px;">
                    <div style="font-size: 11px; color: #6b7280; margin-bottom: 4px;">Signal Validation Metrics (${activeValidations.length} active)</div>
                    ${longValidations.map(sig => `<div style="display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 6px; font-size: 11px; padding-bottom: 4px; border-bottom: 1px solid #e5e7eb;">
                        <span class="dir-long">‚ñ≤ LONG:</span>
                        <span style="flex: 1; min-width: 100px;">${sig.signal.replace(/_/g, ' ').substring(0, 20)}</span>
                        ${sig.profitFactor ? `<span>PF: <strong style="color: ${sig.profitFactor > 1.5 ? '#059669' : sig.profitFactor > 1.2 ? '#d97706' : '#ef4444'}">${sig.profitFactor.toFixed(2)}</strong></span>` : ''}
                        ${sig.testTrades ? `<span style="color: #6b7280;">${sig.testTrades} trades</span>` : ''}
                        ${sig.timeframe ? `<span style="color: #3b82f6;">(${sig.timeframe})</span>` : ''}
                    </div>`).join('')}
                    ${shortValidations.map(sig => `<div style="display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 6px; font-size: 11px; padding-bottom: 4px; border-bottom: 1px solid #e5e7eb;">
                        <span class="dir-short">‚ñº SHORT:</span>
                        <span style="flex: 1; min-width: 100px;">${sig.signal.replace(/_/g, ' ').substring(0, 20)}</span>
                        ${sig.profitFactor ? `<span>PF: <strong style="color: ${sig.profitFactor > 1.5 ? '#059669' : sig.profitFactor > 1.2 ? '#d97706' : '#ef4444'}">${sig.profitFactor.toFixed(2)}</strong></span>` : ''}
                        ${sig.testTrades ? `<span style="color: #6b7280;">${sig.testTrades} trades</span>` : ''}
                        ${sig.timeframe ? `<span style="color: #3b82f6;">(${sig.timeframe})</span>` : ''}
                    </div>`).join('')}
                   </div>`
                : '';

            container.innerHTML = `
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                    <span style="font-weight: 600; font-size: 14px;">${modelInfo.symbol}</span>
                    <span style="padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: 500;
                           background: ${modelInfo.enabled ? '#dcfce7' : '#fee2e2'};
                           color: ${modelInfo.enabled ? '#166534' : '#991b1b'};">
                        ${modelInfo.enabled ? 'ENABLED' : 'DISABLED'}
                    </span>
                </div>
                <div style="margin-bottom: 8px;">
                    <span style="color: #6b7280;">Signal TF:</span>
                    <span style="font-weight: 500; padding: 2px 6px; background: ${activePosition ? '#fef3c7' : '#dbeafe'}; color: ${activePosition ? '#92400e' : '#1e40af'}; border-radius: 4px;">${activeTimeframe}</span>
                </div>
                ${signalInfo}
                <div style="margin-bottom: 8px;">
                    <span style="color: #6b7280;">Exit Strategy:</span>
                    <span style="font-weight: 500;">${modelInfo.exitStrategy}</span>
                </div>
                <div style="margin-bottom: 8px;">
                    <span style="color: #6b7280;">RL Exit Model:</span> ${rlStatus}
                </div>
                ${dirModelHtml}
                ${livePerformanceHtml}
                ${allSignalsHtml}
                ${validationInfo}
            `;
        }

        // Normalize direction fields to lowercase throughout nested model objects
        function normalizeDirections(obj) {
            if (!obj || typeof obj !== 'object') return obj;
            if (Array.isArray(obj)) return obj.map(normalizeDirections);
            const result = {...obj};
            if (typeof result.direction === 'string') result.direction = result.direction.toLowerCase();
            for (const key of Object.keys(result)) {
                if (typeof result[key] === 'object' && result[key] !== null) {
                    result[key] = normalizeDirections(result[key]);
                }
            }
            return result;
        }

        // Fetch all models info (for paper trading dashboard)
        async function fetchAllModelsInfo() {
            try {
                const response = await fetch(`${API_BASE}/paper-trading/models`);
                if (!response.ok) return null;
                const result = await response.json();
                return normalizeDirections(result.data);
            } catch (error) {
                console.warn('Models info not available:', error);
                return null;
            }
        }

        // Update models overview in paper trading dashboard
        async function updateModelsOverview() {
            const container = document.getElementById('modelsOverview');
            const statusEl = document.getElementById('modelsStatus');

            const [data, performanceMap, livePerformanceMap] = await Promise.all([
                fetchAllModelsInfo(),
                fetchModelPerformance(),
                fetchLiveTradingPerformance()
            ]);

            if (!data || !data.symbols) {
                container.innerHTML = '<div style="color: #6b7280; text-align: center; padding: 20px; grid-column: 1 / -1;">Unable to load models</div>';
                statusEl.textContent = 'Error loading models';
                return;
            }

            // Update status
            const { systemStatus } = data;
            statusEl.innerHTML = `<span style="color: #10b981;">${systemStatus.enabledSymbols} enabled</span> | ${systemStatus.h4Symbols} H4 | ${systemStatus.d1Symbols} D1 | ${systemStatus.totalModels} models`;

            // Generate model cards
            const cards = data.symbols.map(model => {
                const statusBadge = model.enabled
                    ? '<span style="padding: 2px 6px; border-radius: 4px; font-size: 10px; background: #dcfce7; color: #166534;">ACTIVE</span>'
                    : '<span style="padding: 2px 6px; border-radius: 4px; font-size: 10px; background: #fee2e2; color: #991b1b;">DISABLED</span>';

                const timeframeBadge = `<span style="padding: 2px 6px; border-radius: 4px; font-size: 10px; background: ${model.timeframe === 'H4' ? '#dbeafe' : '#e0e7ff'}; color: ${model.timeframe === 'H4' ? '#1e40af' : '#3730a3'};" title="Signal detection timeframe">${model.timeframe}</span>`;

                const signalText = model.signal
                    ? `<span class="${model.signal.direction === 'long' ? 'dir-long' : 'dir-short'}">${model.signal.signal.replace(/_/g, ' ')}</span>`
                    : '<span style="color: #6b7280;">-</span>';

                const rlIcon = model.rlModel.available
                    ? `<span style="color: #10b981;" title="${model.rlModel.foldCount} folds">‚úì</span>`
                    : '<span style="color: #d1d5db;">‚úó</span>';

                // All validated signals (LONG + SHORT) with explanations - Show PF as primary metric
                const allSigs = model.allValidatedSignals || {};
                const longExpl = allSigs.long?.explanation || allSigs.long?.signal?.replace(/_/g, ' ') || 'No signal';
                const shortExpl = allSigs.short?.explanation || allSigs.short?.signal?.replace(/_/g, ' ') || 'No signal';

                // Get PF from activeSignalValidations for better data
                const activeValidations = model.activeSignalValidations || [];
                const longActiveVal = activeValidations.find(v => v.direction === 'long');
                const shortActiveVal = activeValidations.find(v => v.direction === 'short');

                const longPF = longActiveVal?.profitFactor || allSigs.long?.profitFactor;
                const shortPF = shortActiveVal?.profitFactor || allSigs.short?.profitFactor;

                const longSig = allSigs.long ? `<span class="dir-long" title="${longExpl}${longPF ? ` (PF:${longPF.toFixed(2)})` : ''}">${longPF ? `PF:${longPF.toFixed(2)}` : allSigs.long.oosWinRate + '%'}</span>` : '<span style="color: #d1d5db;">-</span>';
                const shortSig = allSigs.short ? `<span class="dir-short" title="${shortExpl}${shortPF ? ` (PF:${shortPF.toFixed(2)})` : ''}">${shortPF ? `PF:${shortPF.toFixed(2)}` : allSigs.short.oosWinRate + '%'}</span>` : '<span style="color: #d1d5db;">-</span>';

                // Direction-specific models (Issue #512) with REAL profitability metrics
                const dirModels = model.directionModels || {};
                const formatDirModelWithPerf = (dm, direction) => {
                    if (!dm) return `<span style="color: #d1d5db;">No model</span>`;
                    if (!dm.available) return `<span style="color: #f59e0b;" title="Model not found">‚ö† Not found</span>`;

                    // Get performance data
                    const perfKey = `${model.symbol}_${direction}`;
                    const perf = performanceMap?.[perfKey];

                    if (!perf) {
                        // Fallback to old validation data with warning
                        return `<span style="color: #f59e0b;" title="‚ö†Ô∏è NOT VALIDATED\nFold ${dm.fold}\n${Math.round(dm.validationWinRate)}% WR on ${dm.validationTrades} trades\n${dm.modelPath}">‚ö† ${Math.round(dm.validationWinRate)}% (${dm.validationTrades} trades)</span>`;
                    }

                    // Determine status
                    let statusIcon;
                    if (perf.is_profitable && perf.profit_factor > 1.2) {
                        statusIcon = '‚úÖ';
                    } else if (perf.is_profitable && perf.profit_factor <= 1.2) {
                        statusIcon = '‚ö†Ô∏è';
                    } else {
                        statusIcon = '‚ùå';
                    }

                    const tooltip = `Total Trades: ${perf.total_trades}
Win Rate: ${perf.win_rate.toFixed(1)}%
Avg Win: +${perf.avg_win.toFixed(1)} pips
Avg Loss: ${perf.avg_loss.toFixed(1)} pips
R:R: ${perf.risk_reward_ratio.toFixed(2)}:1
Expectancy: ${perf.expectancy.toFixed(2)} pips/trade
Profit Factor: ${perf.profit_factor.toFixed(2)}
Total PnL: ${perf.total_pnl_after_costs.toFixed(1)} pips (after costs)
Max DD: ${perf.max_drawdown_pips.toFixed(1)} pips (${perf.max_drawdown_percent.toFixed(1)}%)
Sharpe: ${perf.sharpe_ratio.toFixed(2)}
Status: ${perf.status.toUpperCase()} ${statusIcon}
Fold: ${dm.fold}`;

                    const color = perf.is_profitable ? (perf.profit_factor > 1.2 ? '#16a34a' : '#ca8a04') : '#dc2626';
                    return `<span style="color: ${color}; font-weight: 600;" title="${tooltip}">${perf.win_rate.toFixed(1)}% | ${perf.expectancy >= 0 ? '+' : ''}${perf.expectancy.toFixed(1)} pips ${statusIcon}</span>`;
                };
                const longModel = formatDirModelWithPerf(dirModels.long, 'long');
                const shortModel = formatDirModelWithPerf(dirModels.short, 'short');

                // Format LIVE trading performance from paper_trades
                const formatLivePerf = (direction) => {
                    const perfKey = `${model.symbol}_${direction}`;
                    const perf = livePerformanceMap?.[perfKey];
                    if (!perf || perf.total_trades === 0) {
                        return `<span style="color: #d1d5db;">No trades yet</span>`;
                    }

                    const pnlColor = perf.total_pnl_pips >= 0 ? '#16a34a' : '#dc2626';
                    const wrColor = perf.win_rate >= 50 ? '#16a34a' : (perf.win_rate >= 40 ? '#ca8a04' : '#dc2626');
                    const tooltip = `Trades: ${perf.total_trades} (${perf.winning_trades}W/${perf.losing_trades}L)
Win Rate: ${perf.win_rate}%
Total PnL: ${perf.total_pnl_pips >= 0 ? '+' : ''}${perf.total_pnl_pips} pips
Avg PnL: ${perf.avg_pnl_pips >= 0 ? '+' : ''}${perf.avg_pnl_pips} pips/trade
PF: ${perf.profit_factor === Infinity ? '‚àû' : perf.profit_factor.toFixed(2)}
First: ${perf.first_trade ? new Date(perf.first_trade).toLocaleDateString() : '-'}
Last: ${perf.last_trade ? new Date(perf.last_trade).toLocaleDateString() : '-'}`;

                    return `<span style="color: ${wrColor}; font-weight: 600;" title="${tooltip}">${perf.win_rate}% (${perf.total_trades}) | <span style="color: ${pnlColor}">${perf.total_pnl_pips >= 0 ? '+' : ''}${perf.total_pnl_pips} pips</span></span>`;
                };
                const longLive = formatLivePerf('long');
                const shortLive = formatLivePerf('short');

                // Pipeline status indicators
                const pipeline = model.pipeline || {};
                const getPipelineIcon = (status) => {
                    if (status === 'complete') return '‚úÖ';
                    if (status === 'running') return 'üîÑ';
                    return '‚ö™';
                };
                const signalDiscIcon = getPipelineIcon(pipeline.signalDiscovery);
                const optunaIcon = getPipelineIcon(pipeline.optuna?.status);
                const trainingIcon = getPipelineIcon(pipeline.training?.status);
                const paperIcon = pipeline.paperTrading === 'active' ? 'üü¢' : (pipeline.paperTrading === 'ready' ? 'üü°' : '‚ö™');

                const optunaInfo = pipeline.optuna?.bestWinRate
                    ? `${pipeline.optuna.bestWinRate.toFixed(1)}%`
                    : (pipeline.optuna?.status === 'running' ? 'Running...' : '-');

                const trainingInfo = pipeline.training?.foldCount > 0
                    ? `${pipeline.training.foldCount}/${pipeline.training.targetFolds}`
                    : '-';

                return `
                    <div style="background: #f9fafb; padding: 12px; border-radius: 8px; border: 1px solid #e5e7eb; ${!model.enabled ? 'opacity: 0.6;' : ''}">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="font-weight: 600;">${model.symbol}</span>
                            <div style="display: flex; gap: 4px;">
                                ${timeframeBadge}
                                ${statusBadge}
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; font-size: 11px;">
                            <div style="color: #6b7280;">Active Signal:</div>
                            <div>${signalText}</div>
                            <div style="color: #6b7280;">‚ñ≤ LONG:</div>
                            <div>${longSig}</div>
                            <div style="color: #6b7280;">‚ñº SHORT:</div>
                            <div>${shortSig}</div>
                        </div>
                        ${(allSigs.long || allSigs.short) ? `
                        <div style="margin-top: 6px; padding: 6px; background: #f3f4f6; border-radius: 4px; font-size: 10px;">
                            <div style="font-weight: 600; color: #374151; margin-bottom: 4px;">Entry Conditions:</div>
                            ${allSigs.long ? `<div style="color: #16a34a; margin-bottom: 2px;">‚ñ≤ ${longExpl}</div>` : ''}
                            ${allSigs.short ? `<div style="color: #dc2626;">‚ñº ${shortExpl}</div>` : ''}
                        </div>
                        ` : ''}
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; font-size: 11px; margin-top: 6px;">
                            <div style="color: #6b7280;">Exit Strategy:</div>
                            <div>${model.exitStrategy}</div>
                            <div style="color: #6b7280;">RL Model:</div>
                            <div>${rlIcon} ${model.rlModel.foldCount > 0 ? `(${model.rlModel.foldCount} folds)` : ''}</div>
                        </div>
                        ${(dirModels.long || dirModels.short) ? `
                        <div style="margin-top: 6px; padding: 6px; background: #eff6ff; border-radius: 4px; border: 1px solid #bfdbfe; font-size: 10px;">
                            <div style="font-weight: 600; color: #1e40af; margin-bottom: 4px;">üí∞ Real Profitability (Validation)</div>
                            <div style="display: grid; grid-template-columns: auto 1fr; gap: 4px;">
                                <div style="color: #6b7280;">‚ñ≤ LONG:</div>
                                <div>${longModel}</div>
                                <div style="color: #6b7280;">‚ñº SHORT:</div>
                                <div>${shortModel}</div>
                            </div>
                            ${!performanceMap ? '<div style="font-size: 9px; color: #6b7280; margin-top: 4px;">‚ö†Ô∏è Performance data unavailable</div>' : ''}
                        </div>
                        ` : ''}
                        ${livePerformanceMap ? `
                        <div style="margin-top: 6px; padding: 6px; background: #f0fdf4; border-radius: 4px; border: 1px solid #bbf7d0; font-size: 10px;">
                            <div style="font-weight: 600; color: #166534; margin-bottom: 4px;">üìà Live Trading Performance</div>
                            <div style="display: grid; grid-template-columns: auto 1fr; gap: 4px;">
                                <div style="color: #6b7280;">‚ñ≤ LONG:</div>
                                <div>${longLive}</div>
                                <div style="color: #6b7280;">‚ñº SHORT:</div>
                                <div>${shortLive}</div>
                            </div>
                        </div>
                        ` : ''}
                        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e5e7eb;">
                            <div style="font-size: 10px; font-weight: 600; color: #6b7280; margin-bottom: 4px;">Pipeline Status</div>
                            <div style="display: flex; gap: 8px; font-size: 10px;">
                                <span title="Signal Discovery">${signalDiscIcon} Signals</span>
                                <span title="Optuna Tuning: ${optunaInfo}">${optunaIcon} Optuna</span>
                                <span title="Training: ${trainingInfo}">${trainingIcon} Train</span>
                                <span title="Paper Trading">${paperIcon} Live</span>
                            </div>
                            ${pipeline.optuna?.bestWinRate ? `<div style="font-size: 10px; color: #10b981; margin-top: 4px;">Best WR: ${pipeline.optuna.bestWinRate.toFixed(1)}% | Folds: ${trainingInfo}</div>` : ''}
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = cards;
        }

        // Track expanded state for sidebar models
        const expandedModels = new Set();

        // Toggle model expansion in sidebar (global for onclick)
        window.toggleModelExpand = function(symbol) {
            if (expandedModels.has(symbol)) {
                expandedModels.delete(symbol);
            } else {
                expandedModels.add(symbol);
            }
            updateSidebarModels();
        }

        // Update compact sidebar models list for Paper Trading view (expandable)
        async function updateSidebarModels() {
            const container = document.getElementById('sidebarModelsContent');
            const statusEl = document.getElementById('sidebarModelsStatus');

            const data = await fetchAllModelsInfo();

            if (!data || !data.symbols) {
                container.innerHTML = '<div style="color: #6b7280; text-align: center; padding: 8px;">Unable to load</div>';
                statusEl.textContent = 'Error';
                return;
            }

            // Fetch performance data for real profitability metrics
            const performanceMap = await fetchModelPerformance();

            // Update status
            const { systemStatus } = data;
            statusEl.innerHTML = `${systemStatus.enabledSymbols} active`;

            // Generate expandable model list
            const items = data.symbols.map(model => {
                const isExpanded = expandedModels.has(model.symbol);
                const expandIcon = isExpanded ? '‚ñº' : '‚ñ∂';

                const statusDot = model.enabled
                    ? '<span style="color: #10b981;">‚óè</span>'
                    : '<span style="color: #d1d5db;">‚óã</span>';

                const tfBadge = `<span style="padding: 1px 4px; border-radius: 3px; font-size: 9px; background: ${model.timeframe === 'H4' ? '#dbeafe' : '#e0e7ff'}; color: ${model.timeframe === 'H4' ? '#1e40af' : '#3730a3'};">${model.timeframe}</span>`;

                // Active signals - show all (not just first one)
                const activeSignals = model.activeSignals || (model.signal ? [model.signal] : []);
                const signalInfo = activeSignals.length > 0
                    ? activeSignals.map(sig =>
                        `<span class="${sig.direction === 'long' ? 'dir-long' : 'dir-short'}" style="font-size: 9px;">${sig.signal.replace(/_/g, ' ').substring(0, 15)}${sig.signal.length > 15 ? '...' : ''}</span>`
                      ).join('<br/>')
                    : '<span style="color: #9ca3af; font-size: 9px;">No signal</span>';

                // Pipeline indicators
                const pipeline = model.pipeline || {};
                const trainingInfo = pipeline.training?.foldCount > 0
                    ? `${pipeline.training.foldCount}/${pipeline.training.targetFolds}`
                    : '-';

                // Check if direction-specific models are trained (Issue #512)
                const dirModels = model.directionModels || {};
                const hasDirectionModels = dirModels.long?.available || dirModels.short?.available;

                // Show different status for direction-specific vs generic models
                let trainingStatus;
                if (pipeline.training?.status === 'complete') {
                    trainingStatus = hasDirectionModels ? 'üéØ' : '‚ö°';  // üéØ = direction-specific, ‚ö° = generic only
                } else if (pipeline.training?.status === 'running') {
                    trainingStatus = 'üîÑ';
                } else {
                    trainingStatus = '‚ö™';
                }

                // Win rates - use REAL profitability metrics if available, then activeSignalValidations
                const allSigs = model.allValidatedSignals || {};
                const activeValidationsForWr = model.activeSignalValidations || [];
                let longWr, shortWr, longPerfDetails, shortPerfDetails;

                // Get all LONG signal data from activeSignalValidations (includes Phase 5 metrics)
                const longSignalData = activeValidationsForWr
                    .filter(v => v.direction === 'long' && v.oosWinRate > 0);
                const longSignalWrs = longSignalData.map(v => v.oosWinRate);
                // Get all SHORT signal data
                const shortSignalData = activeValidationsForWr
                    .filter(v => v.direction === 'short' && v.oosWinRate > 0);
                const shortSignalWrs = shortSignalData.map(v => v.oosWinRate);

                // Get performance data for LONG
                const longPerfKey = `${model.symbol}_long`;
                const longPerf = performanceMap?.[longPerfKey];
                if (longPerf) {
                    const longIcon = longPerf.is_profitable ? (longPerf.profit_factor > 1.2 ? '‚úÖ' : '‚ö†Ô∏è') : '‚ùå';
                    longWr = `PF:${longPerf.profit_factor.toFixed(2)} ${longIcon}`;
                    longPerfDetails = `${longPerf.expectancy >= 0 ? '+' : ''}${longPerf.expectancy.toFixed(1)} pips/trade | ${longPerf.total_trades} trades`;
                } else if (longSignalData.length > 0) {
                    // Show all LONG signal PFs with Phase 5 metrics (PF primary)
                    const hasPhase5 = longSignalData.some(v => v.profitFactor !== null);
                    if (hasPhase5) {
                        // Format: PF (trades) for each signal
                        longWr = longSignalData.map(v =>
                            v.profitFactor ? `PF:${v.profitFactor.toFixed(2)}` : `${v.oosWinRate}%`
                        ).join(' / ');
                        // Calculate totals for details
                        const totalTrades = longSignalData.reduce((sum, v) => sum + (v.testTrades || 0), 0);
                        const avgPF = longSignalData.filter(v => v.profitFactor).reduce((sum, v) => sum + v.profitFactor, 0) / longSignalData.filter(v => v.profitFactor).length;
                        longPerfDetails = `${longSignalData.length} signal(s) | Avg PF: ${avgPF.toFixed(2)} | ~${totalTrades} trades (Phase 5)`;
                    } else {
                        longWr = longSignalWrs.map(wr => `${wr}%`).join(' / ') + ' ‚ö†';
                        longPerfDetails = `${longSignalWrs.length} signal(s) - NOT VALIDATED`;
                    }
                } else if (dirModels.long?.available && dirModels.long?.validationWinRate) {
                    longWr = `${Math.round(dirModels.long.validationWinRate)}% ‚ö†`;
                    longPerfDetails = 'NOT VALIDATED';
                } else {
                    longWr = allSigs.long?.profitFactor ? `PF:${allSigs.long.profitFactor.toFixed(2)}` : (allSigs.long?.oosWinRate ? `${allSigs.long.oosWinRate}%` : '-');
                    longPerfDetails = null;
                }

                // Get performance data for SHORT
                const shortPerfKey = `${model.symbol}_short`;
                const shortPerf = performanceMap?.[shortPerfKey];
                if (shortPerf) {
                    const shortIcon = shortPerf.is_profitable ? (shortPerf.profit_factor > 1.2 ? '‚úÖ' : '‚ö†Ô∏è') : '‚ùå';
                    shortWr = `PF:${shortPerf.profit_factor.toFixed(2)} ${shortIcon}`;
                    shortPerfDetails = `${shortPerf.expectancy >= 0 ? '+' : ''}${shortPerf.expectancy.toFixed(1)} pips/trade | ${shortPerf.total_trades} trades`;
                } else if (shortSignalData.length > 0) {
                    // Show all SHORT signal PFs with Phase 5 metrics (PF primary)
                    const hasPhase5 = shortSignalData.some(v => v.profitFactor !== null);
                    if (hasPhase5) {
                        shortWr = shortSignalData.map(v =>
                            v.profitFactor ? `PF:${v.profitFactor.toFixed(2)}` : `${v.oosWinRate}%`
                        ).join(' / ');
                        const totalTrades = shortSignalData.reduce((sum, v) => sum + (v.testTrades || 0), 0);
                        const avgPF = shortSignalData.filter(v => v.profitFactor).reduce((sum, v) => sum + v.profitFactor, 0) / shortSignalData.filter(v => v.profitFactor).length;
                        shortPerfDetails = `${shortSignalData.length} signal(s) | Avg PF: ${avgPF.toFixed(2)} | ~${totalTrades} trades (Phase 5)`;
                    } else {
                        shortWr = shortSignalWrs.map(wr => `${wr}%`).join(' / ') + ' ‚ö†';
                        shortPerfDetails = `${shortSignalWrs.length} signal(s) - NOT VALIDATED`;
                    }
                } else if (dirModels.short?.available && dirModels.short?.validationWinRate) {
                    shortWr = `${Math.round(dirModels.short.validationWinRate)}% ‚ö†`;
                    shortPerfDetails = 'NOT VALIDATED';
                } else {
                    shortWr = allSigs.short?.profitFactor ? `PF:${allSigs.short.profitFactor.toFixed(2)}` : (allSigs.short?.oosWinRate ? `${allSigs.short.oosWinRate}%` : '-');
                    shortPerfDetails = null;
                }

                // Expanded details section
                let expandedContent = '';
                if (isExpanded) {
                    // Entry Conditions - use activeSignalValidations for all signals
                    const activeValidations = model.activeSignalValidations || [];
                    const longValidations = activeValidations.filter(v => v.direction === 'long');
                    const shortValidations = activeValidations.filter(v => v.direction === 'short');

                    // Format all signals with their explanations, PF (primary), trades, and timeframe (Phase 5 metrics)
                    const formatSignalDetails = (v) => {
                        let details = `${v.explanation}<br/>`;
                        if (v.profitFactor) {
                            details += `<strong style="color: ${v.profitFactor > 1.5 ? '#10b981' : v.profitFactor > 1.2 ? '#f59e0b' : '#ef4444'}">PF: ${v.profitFactor.toFixed(2)}</strong>`;
                        } else {
                            details += `<strong style="color: ${v.oosWinRate > 53.7 ? '#10b981' : '#6b7280'}">WR: ${v.oosWinRate}%</strong>`;
                        }
                        if (v.testTrades) {
                            details += ` | ${v.testTrades} trades`;
                        }
                        if (v.timeframe) {
                            details += ` <span style="color: #6b7280;">(${v.timeframe})</span>`;
                        }
                        return details;
                    };
                    const longExpl = longValidations.length > 0
                        ? longValidations.map(formatSignalDetails).join('<br/><br/>')
                        : (allSigs.long?.explanation || 'Not configured');
                    const shortExpl = shortValidations.length > 0
                        ? shortValidations.map(formatSignalDetails).join('<br/><br/>')
                        : (allSigs.short?.explanation || 'Not configured');

                    // Pipeline status icons
                    const getPipelineIcon = (status) => {
                        if (status === 'complete') return '‚úÖ';
                        if (status === 'running') return 'üîÑ';
                        return '‚ö™';
                    };
                    const signalDiscIcon = getPipelineIcon(pipeline.signalDiscovery);
                    const optunaIcon = getPipelineIcon(pipeline.optuna?.status);
                    const trainingIcon = getPipelineIcon(pipeline.training?.status);
                    const paperIcon = pipeline.paperTrading === 'active' ? 'üü¢' : (pipeline.paperTrading === 'ready' ? 'üü°' : '‚ö™');

                    const optunaInfo = pipeline.optuna?.bestWinRate
                        ? `${pipeline.optuna.bestWinRate.toFixed(1)}%`
                        : (pipeline.optuna?.status === 'running' ? 'Running...' : '-');

                    // RL Model status
                    const rlStatus = model.rlModel?.available
                        ? `<span style="color: #10b981;">‚úì ${model.rlModel.foldCount} folds</span>`
                        : '<span style="color: #d1d5db;">‚úó Not available</span>';

                    // Exit strategy
                    const exitStrategy = model.rlModel?.available ? 'RL-Managed' : 'SL/TP Fixed';

                    // Direction-specific models (Issue #512) - dirModels already defined above
                    const formatDirModelExp = (dm, dir) => {
                        if (!dm) return '<span style="color: #d1d5db;">Not configured</span>';
                        if (!dm.available) return '<span style="color: #f59e0b;">Model not found</span>';

                        // Get performance data
                        const perfKey = `${model.symbol}_${dir}`;
                        const perf = performanceMap?.[perfKey];

                        if (!perf) {
                            return `<span style="color: #f59e0b;">‚ö† NOT VALIDATED - Fold ${dm.fold} | ${Math.round(dm.validationWinRate)}% WR | ${dm.validationTrades} trades</span>`;
                        }

                        const icon = perf.is_profitable ? (perf.profit_factor > 1.2 ? '‚úÖ' : '‚ö†Ô∏è') : '‚ùå';
                        const color = perf.is_profitable ? (perf.profit_factor > 1.2 ? '#16a34a' : '#ca8a04') : '#dc2626';
                        return `<span style="color: ${color};">Fold ${dm.fold} | ${perf.win_rate.toFixed(1)}% WR | ${perf.expectancy >= 0 ? '+' : ''}${perf.expectancy.toFixed(1)} pips/trade | PF: ${perf.profit_factor.toFixed(2)} ${icon}</span>`;
                    };

                    expandedContent = `
                        <div style="margin-top: 8px; padding: 8px; background: #f9fafb; border-radius: 6px; font-size: 10px;">
                            <!-- Entry Conditions -->
                            <div style="margin-bottom: 8px;">
                                <div style="font-weight: 600; color: #374151; margin-bottom: 4px;">üìà Entry Conditions & Performance</div>
                                <div style="display: flex; gap: 8px;">
                                    <div style="flex: 1;">
                                        <div class="dir-long" style="font-weight: 500;">LONG:</div>
                                        <div style="color: #6b7280; word-break: break-word;">${longExpl}</div>
                                        <div style="margin-top: 2px;">Win Rate: <span class="dir-long">${longWr}</span></div>
                                        ${longPerfDetails ? `<div style="color: #6b7280; font-size: 9px;">${longPerfDetails}</div>` : ''}
                                    </div>
                                    <div style="flex: 1;">
                                        <div class="dir-short" style="font-weight: 500;">SHORT:</div>
                                        <div style="color: #6b7280; word-break: break-word;">${shortExpl}</div>
                                        <div style="margin-top: 2px;">Win Rate: <span class="dir-short">${shortWr}</span></div>
                                        ${shortPerfDetails ? `<div style="color: #6b7280; font-size: 9px;">${shortPerfDetails}</div>` : ''}
                                    </div>
                                </div>
                            </div>

                            <!-- Exit Strategy -->
                            <div style="margin-bottom: 8px;">
                                <div style="font-weight: 600; color: #374151; margin-bottom: 4px;">üéØ Exit Strategy</div>
                                <div style="color: #6b7280;">${exitStrategy}</div>
                                <div style="color: #6b7280;">RL Model: ${rlStatus}</div>
                                ${(dirModels.long || dirModels.short) ? `
                                <div style="margin-top: 4px; padding: 4px; background: #eff6ff; border-radius: 4px; border: 1px solid #bfdbfe;">
                                    <div style="font-weight: 500; color: #1e40af; margin-bottom: 2px;">ü§ñ Direction Models</div>
                                    <div style="color: #10b981;">‚ñ≤ LONG: ${formatDirModelExp(dirModels.long, 'long')}</div>
                                    <div style="color: #ef4444;">‚ñº SHORT: ${formatDirModelExp(dirModels.short, 'short')}</div>
                                </div>
                                ` : ''}
                            </div>

                            <!-- Pipeline Status -->
                            <div>
                                <div style="font-weight: 600; color: #374151; margin-bottom: 4px;">‚öôÔ∏è Pipeline Status</div>
                                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 4px;">
                                    <div>${signalDiscIcon} Signals</div>
                                    <div>${optunaIcon} Optuna ${optunaInfo !== '-' ? '(' + optunaInfo + ')' : ''}</div>
                                    <div>${trainingIcon} Train ${trainingInfo !== '-' ? '(' + trainingInfo + ')' : ''}</div>
                                    <div>${paperIcon} Live</div>
                                </div>
                            </div>
                        </div>
                    `;
                }

                return `
                    <div style="border-bottom: 1px solid #f3f4f6; ${!model.enabled ? 'opacity: 0.5;' : ''}">
                        <div style="padding: 6px 0; cursor: pointer;" onclick="toggleModelExpand('${model.symbol}')">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="display: flex; align-items: center; gap: 4px;">
                                    <span style="font-size: 8px; color: #9ca3af;">${expandIcon}</span>
                                    ${statusDot}
                                    <span style="font-weight: 600; font-size: 11px;">${model.symbol}</span>
                                    ${tfBadge}
                                </div>
                                <span style="font-size: 9px; color: #6b7280;" title="${hasDirectionModels ? 'Direction-specific models trained' : 'Generic models only'}">${trainingStatus} ${trainingInfo}</span>
                            </div>
                            <div style="margin-top: 2px; display: flex; justify-content: space-between; padding-left: 16px;">
                                <div>${signalInfo}</div>
                                <div style="font-size: 9px;">
                                    <span class="dir-long" style="font-size: 9px;">${longWr}</span>
                                    <span style="color: #9ca3af;">/</span>
                                    <span class="dir-short" style="font-size: 9px;">${shortWr}</span>
                                </div>
                            </div>
                        </div>
                        ${expandedContent}
                    </div>
                `;
            }).join('');

            container.innerHTML = items;
        }

        // ==========================================
        // Training Orchestrator Functions
        // ==========================================

        let orchestratorCurrentPage = 0;
        const orchestratorPageSize = 20;
        let orchestratorSortBy = '';
        let orchestratorSortOrder = 'desc';

        const orchestratorColumns = [
            { key: 'signal_name', label: 'Signal' },
            { key: 'symbol', label: 'Symbol' },
            { key: 'direction', label: 'Direction' },
            { key: 'timeframe', label: 'TF' },
            { key: 'trades', label: 'Trades' },
            { key: 'status', label: 'Status' },
            { key: 'phase5_passed', label: 'Phase 5' },
            { key: 'profit_factor', label: 'PF' },
            { key: 'win_rate', label: 'WR' },
            { key: 'trainer_vm', label: 'VM' },
            { key: 'completed_at', label: 'Completed' },
        ];

        function orchestratorToggleSort(key) {
            if (orchestratorSortBy === key) {
                orchestratorSortOrder = orchestratorSortOrder === 'desc' ? 'asc' : 'desc';
            } else {
                orchestratorSortBy = key;
                orchestratorSortOrder = 'desc';
            }
            orchestratorCurrentPage = 0;
            renderOrchestratorHeaders();
            loadOrchestratorJobs();
        }

        function renderOrchestratorHeaders() {
            const thead = document.getElementById('orchestratorJobsHead');
            const headerHtml = orchestratorColumns.map(col => {
                let arrow = '';
                if (orchestratorSortBy === col.key) {
                    arrow = orchestratorSortOrder === 'asc' ? ' &#9650;' : ' &#9660;';
                }
                return `<th style="cursor: pointer; user-select: none; white-space: nowrap;" onclick="orchestratorToggleSort('${col.key}')">${col.label}${arrow}</th>`;
            }).join('');
            thead.innerHTML = `<tr>${headerHtml}</tr>`;
        }

        // Load all orchestrator data
        async function loadOrchestratorData() {
            renderOrchestratorHeaders();
            const status = document.getElementById('orchestratorStatus');
            status.className = 'status loading';
            status.textContent = 'Loading...';

            try {
                // Load status and VMs data
                const [statusRes, vmsRes] = await Promise.all([
                    fetch(`${API_BASE}/orchestrator/status`),
                    fetch(`${API_BASE}/orchestrator/vms`)
                ]);

                if (!statusRes.ok || !vmsRes.ok) {
                    throw new Error('API request failed');
                }

                const statusData = await statusRes.json();
                const vmsData = await vmsRes.json();

                updateOrchestratorProgress(statusData.data);
                updateOrchestratorVMs(vmsData.data.vms || vmsData.data);

                // Load jobs with current filter settings (respects dropdown selections)
                await loadOrchestratorJobs();

                status.className = 'status connected';
                const formattedTime = formatDateTime(new Date());
                status.textContent = `Connected | Updated: ${formattedTime}`;
            } catch (error) {
                status.className = 'status error';
                status.textContent = 'Error: ' + error.message;
                console.error('Error loading orchestrator data:', error);

                // Show placeholder data on error
                showOrchestratorPlaceholder();
            }
        }

        // Show placeholder when API not available
        function showOrchestratorPlaceholder() {
            // Overall progress placeholder
            document.getElementById('orchestrator-progress-bar').style.width = '0%';
            document.getElementById('orchestrator-progress-text').textContent = '0/0';
            document.getElementById('orchestrator-completed-count').textContent = '0';
            document.getElementById('orchestrator-profitable-count').textContent = '0';
            document.getElementById('orchestrator-running-count').textContent = '0';
            document.getElementById('orchestrator-failed-count').textContent = '0';
            document.getElementById('orchestrator-pending-count').textContent = '0';

            // Symbol progress placeholder
            const symbols = ['EURCAD', 'EURUSD', 'GBPUSD', 'USDCAD', 'USDCHF', 'EURGBP'];
            const symbolProgressHtml = symbols.map(symbol => `
                <div class="symbol-progress-card">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <span style="font-weight: 600;">${symbol}</span>
                        <span style="font-size: 12px; color: #6b7280;">0/0</span>
                    </div>
                    <div style="background: #e5e7eb; border-radius: 4px; height: 8px; overflow: hidden;">
                        <div style="background: #10b981; height: 100%; width: 0%;"></div>
                    </div>
                </div>
            `).join('');
            document.getElementById('orchestrator-symbol-progress').innerHTML = symbolProgressHtml;

            // VM grid placeholder (3 VMs after quota optimization)
            const vmHtml = [1, 2, 3].map(i => `
                <div class="vm-card terminated">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <span style="font-weight: 600;">trainer-${i}</span>
                        <span class="vm-status-dot terminated"></span>
                    </div>
                    <div style="font-size: 12px; color: #6b7280;">Status: <span style="color: #9ca3af;">TERMINATED</span></div>
                    <div style="font-size: 11px; color: #9ca3af; margin-top: 4px;">No active job</div>
                </div>
            `).join('');
            document.getElementById('orchestrator-vm-grid').innerHTML = vmHtml;

            // Jobs table placeholder
            document.getElementById('orchestratorJobsBody').innerHTML = '<tr><td colspan="11" style="text-align: center; padding: 40px; color: #6b7280;">No jobs available - API not connected</td></tr>';
            document.getElementById('orchestrator-pagination').innerHTML = '';
        }

        // Update overall progress UI
        function updateOrchestratorProgress(data) {
            if (!data) return;

            const total = data.total || 0;
            const completed = data.completed || 0;
            const profitable = data.profitable || 0;
            const running = data.running || 0;
            const failed = data.failed || 0;
            const pending = data.pending || 0;

            // Update progress bar (processed = completed + failed)
            const processed = completed + failed;
            const percentage = total > 0 ? (processed / total) * 100 : 0;
            document.getElementById('orchestrator-progress-bar').style.width = `${percentage}%`;
            document.getElementById('orchestrator-progress-text').textContent = `${processed}/${total}`;

            // Update status counts
            document.getElementById('orchestrator-completed-count').textContent = completed;
            document.getElementById('orchestrator-profitable-count').textContent = profitable;
            document.getElementById('orchestrator-running-count').textContent = running;
            document.getElementById('orchestrator-failed-count').textContent = failed;
            document.getElementById('orchestrator-pending-count').textContent = pending;

            // Update per-symbol progress (API returns snake_case: by_symbol)
            const symbolProgress = data.by_symbol || data.bySymbol || {};
            const symbols = ['EURCAD', 'EURUSD', 'GBPUSD', 'USDCAD', 'USDCHF', 'EURGBP'];
            const symbolProgressHtml = symbols.map(symbol => {
                const symbolData = symbolProgress[symbol] || symbolProgress[symbol.toLowerCase()] || { completed: 0, total: 0 };
                const symbolPercentage = symbolData.total > 0 ? (symbolData.completed / symbolData.total) * 100 : 0;
                return `
                    <div class="symbol-progress-card">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                            <span style="font-weight: 600;">${symbol}</span>
                            <span style="font-size: 12px; color: #6b7280;">${symbolData.completed}/${symbolData.total}</span>
                        </div>
                        <div style="background: #e5e7eb; border-radius: 4px; height: 8px; overflow: hidden;">
                            <div style="background: #10b981; height: 100%; width: ${symbolPercentage}%; transition: width 0.3s;"></div>
                        </div>
                    </div>
                `;
            }).join('');
            document.getElementById('orchestrator-symbol-progress').innerHTML = symbolProgressHtml;
        }

        // Update VM status grid
        function updateOrchestratorVMs(vms) {
            if (!vms || vms.length === 0) {
                // Show placeholder VMs
                const placeholderVms = [1, 2, 3].map(i => ({
                    name: `trainer-${i}`,
                    status: 'TERMINATED',
                    currentJob: null,
                    lastCompletedAt: null
                }));
                vms = placeholderVms;
            }

            const vmHtml = vms.map(vm => {
                const statusLower = (vm.status || 'terminated').toLowerCase();
                const statusDisplay = vm.status || 'TERMINATED';
                const statusColor = statusLower === 'running' ? '#10b981' :
                                   statusLower === 'stopping' ? '#f59e0b' : '#9ca3af';

                // Support both camelCase (currentJob) and snake_case (current_job) from API
                const currentJob = vm.currentJob || vm.current_job;
                const currentJobHtml = currentJob
                    ? `<div style="font-size: 11px; margin-top: 4px;">
                         <span style="color: #3b82f6;">Job:</span>
                         <span>${currentJob.signal_name || currentJob.signal || 'Unknown'}</span>
                         <span style="color: #6b7280;">(${currentJob.symbol || ''})</span>
                       </div>`
                    : '<div style="font-size: 11px; color: #9ca3af; margin-top: 4px;">No active job</div>';

                const lastCompletedAt = vm.lastCompletedAt || vm.last_completed_at;
                const lastCompletedHtml = lastCompletedAt
                    ? `<div style="font-size: 10px; color: #9ca3af; margin-top: 4px;">Last: ${formatDateTime(lastCompletedAt)}</div>`
                    : '';

                return `
                    <div class="vm-card ${statusLower}">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="font-weight: 600;">${vm.name}</span>
                            <span class="vm-status-dot ${statusLower}"></span>
                        </div>
                        <div style="font-size: 12px; color: #6b7280;">
                            Status: <span style="color: ${statusColor}; font-weight: 500;">${statusDisplay}</span>
                        </div>
                        ${currentJobHtml}
                        ${lastCompletedHtml}
                    </div>
                `;
            }).join('');

            document.getElementById('orchestrator-vm-grid').innerHTML = vmHtml;
        }

        // Update jobs table
        function updateOrchestratorJobs(jobs, total) {
            const tbody = document.getElementById('orchestratorJobsBody');

            if (!jobs || jobs.length === 0) {
                tbody.innerHTML = '<tr><td colspan="11" style="text-align: center; padding: 40px;">No jobs found</td></tr>';
                document.getElementById('orchestrator-pagination').innerHTML = '';
                return;
            }

            const jobsHtml = jobs.map(job => {
                const statusLower = (job.status || 'pending').toLowerCase();
                const directionClass = job.direction === 'long' ? 'dir-long' : 'dir-short';

                // Composite status: combine training status with Phase 5 outcome
                let displayStatus = (job.status || 'pending').toUpperCase();
                let statusClass = statusLower;
                if (statusLower === 'completed') {
                    if (job.phase5_passed === true) {
                        displayStatus = 'PROFITABLE';
                        statusClass = 'profitable';
                    } else if (job.phase5_passed === false) {
                        displayStatus = 'PHASE5 FAIL';
                        statusClass = 'phase5-failed';
                    }
                }

                // Phase 5 badge
                let phase5Html = '-';
                if (job.phase5_passed === true) {
                    phase5Html = '<span style="color: #16a34a; font-weight: 600;">PASSED</span>';
                } else if (job.phase5_passed === false) {
                    phase5Html = '<span style="color: #dc2626; font-weight: 600;">FAILED</span>';
                } else if (statusLower === 'completed') {
                    phase5Html = '<span style="color: #9ca3af;">N/A</span>';
                }

                // Profit Factor with color coding
                let pfHtml = '-';
                if (job.profit_factor != null) {
                    const pf = parseFloat(job.profit_factor);
                    const pfColor = pf >= 2.0 ? '#16a34a' : pf >= 1.2 ? '#ca8a04' : '#dc2626';
                    pfHtml = `<span style="color: ${pfColor}; font-weight: 600;">${pf.toFixed(2)}</span>`;
                }

                // Win Rate
                let wrHtml = '-';
                if (job.win_rate != null) {
                    const rawWr = parseFloat(job.win_rate);
                    const wr = rawWr <= 1 ? rawWr * 100 : rawWr;
                    const wrColor = wr >= 60 ? '#16a34a' : wr >= 55 ? '#ca8a04' : '#6b7280';
                    wrHtml = `<span style="color: ${wrColor};">${wr.toFixed(1)}%</span>`;
                }

                // Completed timestamp
                let completedHtml = '-';
                if (job.completed_at) {
                    const d = new Date(job.completed_at);
                    const mon = d.toLocaleString('en-US', { month: 'short' });
                    const day = d.getDate();
                    const hh = String(d.getHours()).padStart(2, '0');
                    const mm = String(d.getMinutes()).padStart(2, '0');
                    completedHtml = `<span title="${job.completed_at}" style="font-size: 11px;">${mon} ${day}, ${hh}:${mm}</span>`;
                }

                return `
                    <tr>
                        <td style="font-size: 12px;" title="${job.signal_name || ''}">${job.signal_name || '-'}</td>
                        <td>${job.symbol || '-'}</td>
                        <td class="${directionClass}">${(job.direction || '-').toUpperCase()}</td>
                        <td>${job.timeframe || '-'}</td>
                        <td>${job.trades != null ? job.trades : '-'}</td>
                        <td><span class="job-status-badge ${statusClass}">${displayStatus}</span></td>
                        <td>${phase5Html}</td>
                        <td>${pfHtml}</td>
                        <td>${wrHtml}</td>
                        <td style="font-size: 12px;">${job.trainer_vm || '-'}</td>
                        <td>${completedHtml}</td>
                    </tr>
                `;
            }).join('');

            tbody.innerHTML = jobsHtml;

            // Update pagination
            updateOrchestratorPagination(total || jobs.length);
        }

        // Update pagination controls
        function updateOrchestratorPagination(total) {
            const totalPages = Math.ceil(total / orchestratorPageSize);
            const paginationEl = document.getElementById('orchestrator-pagination');

            if (totalPages <= 1) {
                paginationEl.innerHTML = '';
                return;
            }

            let paginationHtml = '';

            // Previous button
            paginationHtml += `<button class="pagination-btn" onclick="orchestratorGoToPage(${orchestratorCurrentPage - 1})" ${orchestratorCurrentPage === 0 ? 'disabled' : ''}>Prev</button>`;

            // Page numbers
            const startPage = Math.max(0, orchestratorCurrentPage - 2);
            const endPage = Math.min(totalPages - 1, orchestratorCurrentPage + 2);

            for (let i = startPage; i <= endPage; i++) {
                paginationHtml += `<button class="pagination-btn ${i === orchestratorCurrentPage ? 'active' : ''}" onclick="orchestratorGoToPage(${i})">${i + 1}</button>`;
            }

            // Next button
            paginationHtml += `<button class="pagination-btn" onclick="orchestratorGoToPage(${orchestratorCurrentPage + 1})" ${orchestratorCurrentPage >= totalPages - 1 ? 'disabled' : ''}>Next</button>`;

            paginationEl.innerHTML = paginationHtml;
        }

        // Apply filter and reset to first page
        function orchestratorApplyFilter() {
            orchestratorCurrentPage = 0;
            loadOrchestratorJobs();
        }

        // Go to page
        function orchestratorGoToPage(page) {
            orchestratorCurrentPage = page;
            loadOrchestratorJobs();
        }

        // Load jobs with current filters
        async function loadOrchestratorJobs() {
            const statusFilter = document.getElementById('orchestrator-filter-status').value;
            const symbolFilter = document.getElementById('orchestrator-filter-symbol').value;
            const directionFilter = document.getElementById('orchestrator-filter-direction').value;
            const timeframeFilter = document.getElementById('orchestrator-filter-timeframe').value;
            const phase5Filter = document.getElementById('orchestrator-filter-phase5').value;
            const vmFilter = document.getElementById('orchestrator-filter-vm').value;

            let url = `${API_BASE}/orchestrator/jobs?limit=${orchestratorPageSize}&offset=${orchestratorCurrentPage * orchestratorPageSize}`;
            if (statusFilter) url += `&status=${statusFilter}`;
            if (symbolFilter) url += `&symbol=${symbolFilter}`;
            if (directionFilter) url += `&direction=${directionFilter}`;
            if (timeframeFilter) url += `&timeframe=${timeframeFilter}`;
            if (phase5Filter) url += `&phase5=${phase5Filter}`;
            if (vmFilter) url += `&vm=${vmFilter}`;
            if (orchestratorSortBy) url += `&sort_by=${orchestratorSortBy}&sort_order=${orchestratorSortOrder}`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error('Failed to load jobs');
                const data = await response.json();
                // API returns {data: {jobs: [], total: N}, metadata: {...}}
                const jobsData = data.data || data;
                const jobs = (jobsData.jobs || jobsData).map(j => ({...j, direction: (j.direction || '').toLowerCase()}));
                const total = jobsData.total || (Array.isArray(jobs) ? jobs.length : 0);
                updateOrchestratorJobs(jobs, total);
            } catch (error) {
                console.error('Error loading jobs:', error);
            }
        }

        // Start orchestrator
        async function startOrchestrator() {
            try {
                const response = await fetch(`${API_BASE}/orchestrator/start`, { method: 'POST' });
                if (!response.ok) throw new Error('Failed to start orchestrator');
                const data = await response.json();
                alert(data.message || 'Orchestrator started');
                loadOrchestratorData();
            } catch (error) {
                alert('Failed to start orchestrator: ' + error.message);
            }
        }

        // Pause orchestrator
        async function pauseOrchestrator() {
            try {
                const response = await fetch(`${API_BASE}/orchestrator/pause`, { method: 'POST' });
                if (!response.ok) throw new Error('Failed to pause orchestrator');
                const data = await response.json();
                alert(data.message || 'Orchestrator paused');
                loadOrchestratorData();
            } catch (error) {
                alert('Failed to pause orchestrator: ' + error.message);
            }
        }

        // Retry failed job
        async function retryJob(jobId) {
            try {
                const response = await fetch(`${API_BASE}/orchestrator/retry/${jobId}`, { method: 'POST' });
                if (!response.ok) throw new Error('Failed to retry job');
                const data = await response.json();
                alert(data.message || 'Job queued for retry');
                loadOrchestratorData();
            } catch (error) {
                alert('Failed to retry job: ' + error.message);
            }
        }

        // ========== SIGNAL MONITOR FUNCTIONS ==========

        // Get lot color based on allocation tier
        function getLotColor(lots) {
            if (lots >= 0.5) return '#10b981'; // Green - highest tier
            if (lots >= 0.3) return '#3b82f6'; // Blue - second tier
            if (lots >= 0.2) return '#f59e0b'; // Yellow/amber - third tier
            return '#6b7280'; // Gray - lowest tier
        }

        // Get status color for margin constraints
        function getStatusColor(status) {
            if (status === 'ok' || status === 'available') return '#10b981';
            if (status === 'warning' || status === 'limited') return '#f59e0b';
            if (status === 'exceeded' || status === 'full') return '#ef4444';
            return '#6b7280';
        }

        // Update candle countdown to next H1 and other timeframes
        function updateCandleCountdown() {
            const now = new Date();

            // Main H1 countdown
            const nextHour = new Date(now);
            nextHour.setHours(nextHour.getHours() + 1, 0, 0, 0);
            const diff = nextHour - now;
            const minutes = Math.floor(diff / 60000);
            const seconds = Math.floor((diff % 60000) / 1000);
            const cdEl = document.getElementById('candleCountdown');
            if (cdEl) cdEl.textContent = `Next H1: ${minutes}m ${seconds.toString().padStart(2, '0')}s`;

            // Multiple timeframe countdowns
            const timeframes = [
                { name: 'H1', getNext: () => { const d = new Date(now); d.setHours(d.getHours() + 1, 0, 0, 0); return d; } },
                { name: 'H2', getNext: () => { const d = new Date(now); const h = d.getHours(); d.setHours(h + (2 - h % 2), 0, 0, 0); return d; } },
                { name: 'H4', getNext: () => { const d = new Date(now); const h = d.getHours(); d.setHours(h + (4 - h % 4), 0, 0, 0); return d; } },
            ];

            const container = document.getElementById('timeframeCountdowns');
            if (container) {
                container.innerHTML = timeframes.map(tf => {
                    const next = tf.getNext();
                    const tfDiff = next - now;
                    const tfMins = Math.floor(tfDiff / 60000);
                    const tfSecs = Math.floor((tfDiff % 60000) / 1000);
                    const isUrgent = tfMins < 5;
                    return `<span style="padding: 4px 8px; background: ${isUrgent ? '#dc2626' : '#374151'}; border-radius: 4px; ${isUrgent ? 'animation: pulse 1s infinite;' : ''}">${tf.name}: ${tfMins}m ${tfSecs.toString().padStart(2, '0')}s</span>`;
                }).join('');
            }
        }

        // MT5 live balance state
        let _mt5Balance = null;
        let _mt5Currency = null;  // Set dynamically from API response
        const CURRENCY_USD_RATES = { PLN: 0.2817, EUR: 1.05, GBP: 1.22, CHF: 1.08, JPY: 0.0067, CAD: 0.72, USD: 1.0 };

        async function fetchMT5Account() {
            // TFG: No MT5 broker connection
            return null;
        }

        // Load all monitor data
        async function loadMonitorData() {
            const status = document.getElementById('monitorStatus');
            if (!status) return; // View replaced by redirect card
            // Fetch live MT5 balance, fall back to config
            await fetchMT5Account();
            const balance = _mt5Balance || 13897;
            status.textContent = 'üîÑ Loading...';

            try {
                // Fetch data in parallel (signal preview moved to dashboard.html)
                const [allocationRes, positionsRes] = await Promise.all([
                    fetch(`${API_BASE}/position-sizing/allocation?balance=${balance}`).catch(() => ({ ok: false })),
                    fetch(`${API_BASE}/paper-trading/positions`).catch(() => ({ ok: false }))
                ]);

                let allocation = null;
                let positions = [];

                if (allocationRes.ok) {
                    const allocationData = await allocationRes.json();
                    allocation = allocationData.data || allocationData;
                }

                if (positionsRes.ok) {
                    const posData = await positionsRes.json();
                    // Handle various API response formats for positions
                    // Issue #631: Position id=316 EURGBP LONG is_live=true not showing
                    if (Array.isArray(posData)) {
                        positions = posData;
                    } else if (posData.data?.positions) {
                        positions = posData.data.positions;
                    } else if (posData.positions) {
                        positions = posData.positions;
                    } else if (Array.isArray(posData.data)) {
                        positions = posData.data;
                    } else if (posData.data && typeof posData.data === 'object') {
                        // Handle case where data is an object with position keys
                        positions = Object.values(posData.data);
                    } else {
                        positions = [];
                    }
                    console.log('Positions API response:', posData);
                    console.log('Parsed positions:', positions);
                }

                renderMarginConstraints(allocation);
                renderActivePositions(positions);

                status.textContent = 'üü¢ Updated';
            } catch (error) {
                console.error('Monitor load error:', error);
                status.textContent = 'üî¥ Error';
            }
        }

        // Render margin constraints as symbol cards
        function renderMarginConstraints(allocation) {
            const container = document.getElementById('marginConstraints');
            if (!container) return;

            if (!allocation || !allocation.allocations) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #6b7280;">No allocation data available</div>';
                return;
            }

            const allocations = allocation.allocations || [];

            if (allocations.length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #6b7280;">No symbols allocated</div>';
                return;
            }

            // Show balance info header
            const balanceInfo = `
                <div style="margin-bottom: 12px; padding: 10px 14px; background: #f3f4f6; border-radius: 6px; font-size: 13px; color: #1f2937; font-weight: 500; border: 1px solid #e5e7eb;">
                    üí∞ Balance: <span style="color: #059669; font-weight: 700;">$${allocation.balance?.toLocaleString() || '0'}</span> |
                    Available: <span style="color: #2563eb; font-weight: 700;">$${allocation.availableBalance?.toLocaleString() || '0'}</span> |
                    Max Lots: <span style="color: #d97706; font-weight: 700;">${allocation.maxTotalLots?.toFixed(2) || '0'}</span>
                </div>
            `;

            container.innerHTML = balanceInfo + '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 10px;">' +
                allocations.map(data => {
                const symbol = data.symbol || 'UNKNOWN';
                const status = data.status || 'unknown';
                const statusColor = getStatusColor(status);
                const maxLots = data.maxLots || 0;
                const marginRequired = data.marginRequired || 0;
                const leverage = data.leverage || 0;

                return `
                    <div style="background: #ffffff; border-radius: 8px; padding: 12px; border-left: 4px solid ${statusColor}; border: 1px solid #e5e7eb; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="font-weight: 700; color: #1f2937; font-size: 14px;">${symbol}</span>
                            <span style="font-size: 10px; padding: 2px 6px; background: #10b981; color: white; border-radius: 4px; font-weight: 600;">
                                ${leverage}x
                            </span>
                        </div>
                        <div style="font-size: 22px; font-weight: 700; color: #d97706; margin-bottom: 4px;">
                            ${maxLots.toFixed(2)}L
                        </div>
                        <div style="font-size: 12px; color: #6b7280; font-weight: 500;">
                            Margin: $${marginRequired.toFixed(0)}
                        </div>
                    </div>
                `;
            }).join('') + '</div>';
        }

        // Render active positions table
        function renderActivePositions(positions) {
            const tbody = document.getElementById('activePositionsBody');
            if (!tbody) return;

            if (!positions || positions.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; padding: 20px;">No active positions</td></tr>';
                return;
            }

            // Filter to only open positions (status is null, 'open', or missing)
            const openPositions = positions.filter(p => !p.status || p.status === 'open');

            if (openPositions.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; padding: 20px;">No active positions</td></tr>';
                return;
            }

            tbody.innerHTML = openPositions.map(pos => {
                // Handle various field naming conventions from different APIs/DB tables
                const plPips = parseFloat(pos.profit_pips || pos.pl_pips || pos.pnl || 0);
                const plColor = plPips >= 0 ? '#10b981' : '#ef4444';
                const direction = (pos.direction || pos.type || '-').toUpperCase();
                const dirColor = direction === 'LONG' || direction === 'BUY' ? '#10b981' : '#ef4444';
                const entryPrice = parseFloat(pos.entry_price || pos.open_price || 0);
                const currentPrice = parseFloat(pos.current_price || entryPrice); // Fallback to entry if no current
                const lotSize = parseFloat(pos.lot_size || pos.lots || pos.volume || 0);
                const openTime = pos.entry_time || pos.open_time || pos.opened_at;
                const isLive = pos.is_live ? 'üî¥ LIVE' : 'üìù Paper';

                return `
                    <tr>
                        <td style="font-weight: 600;">${pos.symbol || '-'}</td>
                        <td style="color: ${dirColor}; font-weight: 600;">${direction}</td>
                        <td>${lotSize.toFixed(2)}</td>
                        <td>${entryPrice.toFixed(5)}</td>
                        <td>${currentPrice.toFixed(5)}</td>
                        <td style="color: ${plColor}; font-weight: 600;">${plPips >= 0 ? '+' : ''}${plPips.toFixed(1)}</td>
                        <td style="font-size: 11px;">${openTime ? formatDateTime(openTime) : '-'} ${isLive}</td>
                    </tr>
                `;
            }).join('');
        }

        // ========== END SIGNAL MONITOR FUNCTIONS ==========

        // Initialize
        loadData();
        updateModelInfoCard();
        refreshInterval = setInterval(loadData, 60000);

        // Add event listener for symbol change to update model info
        document.getElementById('symbol').addEventListener('change', function() {
            updateModelInfoCard();
        });
    </script>
</body>
</html>
